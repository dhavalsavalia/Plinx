{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Plinx Web Framework","text":"<p>Welcome to the official documentation for Plinx 1.0.0, a simple, lightweight, and educational Python web framework and ORM.</p>"},{"location":"#about-plinx","title":"About Plinx","text":"<p>Plinx is an experimental web framework designed with the following goals:</p> <ul> <li>Simplicity: Clean API with minimal magic</li> <li>Educational Value: Clear implementation for learning purposes</li> <li>Minimalism: Small core with few dependencies</li> <li>Extensibility: Easy to customize and extend</li> <li>Python 3.11+: Taking advantage of modern Python features</li> </ul> <p>Plinx is both a functional web framework for building simple applications and an educational tool for learning how web frameworks and ORMs work under the hood.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#web-framework","title":"Web Framework","text":"<ul> <li>Route Decorators: Simple URL routing with path parameters</li> <li>Request/Response Model: Clean separation of concerns</li> <li>Class-Based Views: Support for HTTP method-specific handlers</li> <li>Middleware System: For global request/response processing</li> <li>WSGI Compatibility: Works with standard WSGI servers</li> </ul>"},{"location":"#orm-object-relational-mapping","title":"ORM (Object-Relational Mapping)","text":"<ul> <li>Simple Table Definitions: Define tables as Python classes</li> <li>SQLite Support: Lightweight database integration</li> <li>Basic CRUD Operations: Create, read, update, delete</li> <li>Relationships: Support for foreign key relationships</li> <li>Type Mapping: Python types to SQLite types</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from plinx import Plinx\n\napp = Plinx()\n\n@app.route(\"/\")\ndef home(request, response):\n    response.text = \"Hello, World!\"\n\n@app.route(\"/hello/{name}\")\ndef hello(request, response, name):\n    response.json = {\"message\": f\"Hello, {name}!\"}\n\nif __name__ == \"__main__\":\n    # For development only\n    from wsgiref.simple_server import make_server\n    server = make_server('localhost', 8000, app)\n    print(\"Server running at http://localhost:8000\")\n    server.serve_forever()\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation: How to install Plinx</li> <li>Quick Start: Create your first Plinx application</li> </ul>"},{"location":"#user-guide","title":"User Guide","text":"<ul> <li>Core Concepts: Fundamental concepts and design</li> <li>Routing: URL routing and parameter handling</li> <li>Middleware: Request and response processing</li> <li>Handling Requests: Working with request data</li> <li>Responses: Generating HTTP responses</li> <li>Class-Based Views: Using classes for route handlers</li> <li>Error Handling: Managing and customizing errors</li> </ul>"},{"location":"#orm-guide","title":"ORM Guide","text":"<ul> <li>ORM Introduction: Getting started with the ORM</li> <li>Tables &amp; Models: Defining database tables</li> <li>Database Operations: Working with data</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Applications: Core application class</li> <li>Methods: HTTP method decorators</li> <li>Middleware: Middleware system</li> <li>Response: HTTP response handling</li> <li>ORM: Database interaction</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Contributing: How to contribute to Plinx</li> <li>Design Philosophy: Principles and tradeoffs</li> </ul>"},{"location":"#about","title":"About","text":"<ul> <li>Release Notes: What's new in 1.0.0</li> <li>License: MIT License information</li> </ul>"},{"location":"#who-should-use-plinx","title":"Who Should Use Plinx?","text":"<ul> <li>Learners: Those interested in understanding web framework internals</li> <li>Teachers: For educational demonstrations of web concepts</li> <li>Developers: Building simple applications or prototypes</li> <li>Contributors: Interested in evolving a minimalist framework</li> </ul> <p>Plinx may not be suitable for large-scale applications with complex requirements. It is intentionally minimalistic and focused on clarity rather than comprehensive features.</p> <p>Thank you for using Plinx! We hope you find it both useful and educational.</p>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2025 Plinx Contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#explanation","title":"Explanation","text":"<p>Plinx is released under the MIT License, which is a permissive license that is short and to the point. It lets people do almost anything they want with the project, like making and distributing closed source versions, as long as they include the original copyright and license notice.</p>"},{"location":"about/license/#what-you-can-do","title":"What You Can Do","text":"<ul> <li>Use Plinx commercially</li> <li>Modify Plinx</li> <li>Distribute your version of Plinx</li> <li>Sublicense Plinx</li> <li>Use Plinx privately</li> <li>Hold the authors and copyright holders harmless in case something goes wrong</li> </ul>"},{"location":"about/license/#conditions","title":"Conditions","text":"<ul> <li>Include the copyright notice and permission notice in all copies or substantial portions of the software</li> </ul>"},{"location":"about/license/#limitations","title":"Limitations","text":"<ul> <li>The license provides no warranty whatsoever</li> <li>The authors are not liable for any claim, damages, or other liability</li> </ul>"},{"location":"about/license/#third-party-components","title":"Third-Party Components","text":"<p>Plinx depends on several third-party libraries, each with their own licenses:</p> <ul> <li>WebOb: MIT License</li> <li>parse: MIT License</li> </ul> <p>These dependencies are compatible with the MIT License of Plinx.</p>"},{"location":"about/release-notes/","title":"Release Notes","text":""},{"location":"about/release-notes/#plinx-100-april-2025","title":"Plinx 1.0.0 (April 2025)","text":"<p>We're excited to announce the release of Plinx 1.0.0! This is the first stable release of our experimental, minimalistic, and extensible WSGI-based web framework and ORM.</p>"},{"location":"about/release-notes/#core-features","title":"Core Features","text":"<ul> <li> <p>WSGI Application Framework</p> <ul> <li>Complete request/response cycle</li> <li>Decorator-based routing system</li> <li>Class-based views</li> <li>HTTP method-specific route handlers</li> <li>URL pattern matching with parameter extraction</li> </ul> </li> <li> <p>Middleware System</p> <ul> <li>Nested middleware architecture</li> <li>Request and response processing hooks</li> <li>Easy extension points for cross-cutting concerns</li> </ul> </li> <li> <p>Response Handling</p> <ul> <li>Simple API for text and JSON responses</li> <li>Custom status codes and headers</li> <li>Content-type negotiation</li> </ul> </li> <li> <p>Lightweight ORM</p> <ul> <li>SQLite database support</li> <li>Table definitions as Python classes</li> <li>Basic CRUD operations</li> <li>Foreign key relationships</li> <li>Python type to SQL type mapping</li> </ul> </li> <li> <p>Testing Support</p> <ul> <li>Test client for making requests to your application</li> <li>No HTTP server required for testing</li> </ul> </li> <li> <p>Modern Python Features</p> <ul> <li>Type hints throughout the codebase</li> <li>Support for Python 3.11+</li> <li>Clean, readable code structure</li> </ul> </li> </ul>"},{"location":"about/release-notes/#notable-design-decisions","title":"Notable Design Decisions","text":"<ul> <li>Explicit Request/Response Model: Unlike some frameworks that use global request objects or return values as responses, Plinx explicitly passes request and response objects to handlers.</li> <li>Minimal Dependencies: Plinx has very few dependencies, making it lightweight and easy to install.</li> <li>Educational Focus: The codebase is designed to be readable and understandable, serving as a learning resource.</li> <li>WSGI Foundation: Built on the proven WSGI standard for broad compatibility and simplicity.</li> </ul>"},{"location":"about/release-notes/#installation","title":"Installation","text":"<p>Plinx 1.0.0 can be installed from PyPI:</p> <pre><code>pip install Plinx\n</code></pre>"},{"location":"about/release-notes/#compatibility","title":"Compatibility","text":"<p>Plinx 1.0.0 requires:</p> <ul> <li>Python 3.11 or higher</li> <li>WebOb</li> <li>parse</li> </ul>"},{"location":"about/release-notes/#documentation","title":"Documentation","text":"<p>Comprehensive documentation is available at:</p> <ul> <li>Online Documentation</li> <li>In the <code>docs/</code> directory of the source code</li> </ul>"},{"location":"about/release-notes/#known-limitations","title":"Known Limitations","text":"<ul> <li>ORM Constraints: The ORM is intentionally simple and currently only supports SQLite</li> <li>Performance: Optimized for clarity and simplicity rather than raw performance</li> <li>Feature Set: Focused on core functionality; some common web framework features are not included</li> </ul>"},{"location":"about/release-notes/#future-roadmap","title":"Future Roadmap","text":"<p>While Plinx 1.0.0 is a stable release, we have plans for future enhancements:</p> <ul> <li>Additional ORM features (more advanced queries, additional relationship types)</li> <li>Optional ASGI support</li> <li>Integration helpers for common third-party libraries</li> <li>Enhanced routing capabilities</li> <li>Template rendering integrations</li> </ul>"},{"location":"about/release-notes/#acknowledgments","title":"Acknowledgments","text":"<p>Special thanks to everyone who contributed to making this release possible, including testers, documentation writers, and early adopters who provided valuable feedback during development.</p>"},{"location":"api/applications/","title":"Applications API","text":"<p>The <code>applications</code> module contains the core <code>Plinx</code> class, which is the main entry point for creating Plinx web applications.</p>"},{"location":"api/applications/#plinx-class","title":"Plinx Class","text":""},{"location":"api/applications/#plinx.applications.Plinx","title":"<code>plinx.applications.Plinx</code>","text":"<p>The main application class for the Plinx web framework.</p> <p>This class serves as the WSGI application entry point and manages routes, middleware, and request handling. It provides a Flask-like decorator syntax for adding routes and Django-like method for explicitly registering them.</p> <p>Examples:</p> <p>Creating a simple app with a route:</p> <pre><code>from plinx import Plinx\n\napp = Plinx()\n\n@app.route(\"/\")\ndef home(request, response):\n    response.text = \"Hello, World!\"\n</code></pre> <p>Using HTTP method-specific decorators:</p> <pre><code>@app.get(\"/users\")\ndef list_users(request, response):\n    response.json = {\"users\": [\"user1\", \"user2\"]}\n\n@app.post(\"/users\")\ndef create_user(request, response):\n    response.text = \"User created\"\n</code></pre> <p>Using class-based views:</p> <pre><code>@app.route(\"/books\")\nclass BooksResource:\n    def get(self, request, response):\n        response.text = \"List of books\"\n\n    def post(self, request, response):\n        response.text = \"Book created\"\n</code></pre> Source code in <code>plinx/applications.py</code> <pre><code>class Plinx:\n    \"\"\"\n    The main application class for the Plinx web framework.\n\n    This class serves as the WSGI application entry point and manages routes,\n    middleware, and request handling. It provides a Flask-like decorator syntax\n    for adding routes and Django-like method for explicitly registering them.\n\n    Examples:\n        Creating a simple app with a route:\n\n        ```python\n        from plinx import Plinx\n\n        app = Plinx()\n\n        @app.route(\"/\")\n        def home(request, response):\n            response.text = \"Hello, World!\"\n        ```\n\n        Using HTTP method-specific decorators:\n\n        ```python\n        @app.get(\"/users\")\n        def list_users(request, response):\n            response.json = {\"users\": [\"user1\", \"user2\"]}\n\n        @app.post(\"/users\")\n        def create_user(request, response):\n            response.text = \"User created\"\n        ```\n\n        Using class-based views:\n\n        ```python\n        @app.route(\"/books\")\n        class BooksResource:\n            def get(self, request, response):\n                response.text = \"List of books\"\n\n            def post(self, request, response):\n                response.text = \"Book created\"\n        ```\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a new Plinx application instance.\n\n        Sets up the routing table, middleware stack, and\n        dynamically generates HTTP method-specific decorators.\n        \"\"\"\n        self.routes: Dict[str, Tuple[HTTPMethods, Callable]] = {}\n        self.exception_handler = None\n        self.middleware = Middleware(self)\n\n        self._method_decorators = {}\n        for method in HTTPMethods:\n            self._method_decorators[method.name.lower()] = (\n                self._create_method_decorator(method)\n            )\n\n    def __call__(\n        self,\n        environ: WSGIEnvironment,\n        start_response: StartResponse,\n    ) -&gt; Iterable[bytes]:\n        \"\"\"\n        WSGI entry point for the application.\n\n        This method makes the Plinx instance callable as required by the WSGI spec,\n        allowing it to be used directly with WSGI servers like Gunicorn or uWSGI.\n\n        Args:\n            environ: The WSGI environment dictionary containing request information\n            start_response: The WSGI start_response callable\n\n        Returns:\n            An iterable of bytes representing the response body\n        \"\"\"\n        return self.middleware(environ, start_response)\n\n    def add_route(\n        self,\n        path: str,\n        handler: Callable,\n        method: HTTPMethods = HTTPMethods.GET,\n    ):\n        \"\"\"\n        Explicitly register a route with the application.\n\n        This provides a Django-like syntax for registering routes,\n        as an alternative to the decorator approach.\n\n        Args:\n            path: URL pattern to match (may contain parameters)\n            handler: Function or class to handle matching requests\n            method: HTTP method to match (defaults to GET)\n\n        Raises:\n            RuntimeError: If the path is already registered\n\n        Example:\n            ```python\n            def home(request, response):\n                response.text = \"Hello, World!\"\n\n            app.add_route(\"/home\", home)\n            ```\n        \"\"\"\n        if path in self.routes:\n            raise RuntimeError(f\"Route '{path}' is already registered.\")\n\n        self.routes[path] = (method, handler)\n\n    def route(\n        self,\n        path: str,\n    ):\n        \"\"\"\n        Register a route via decorator syntax.\n\n        This implements Flask-like syntax for registering routes. It can be used\n        with both function-based handlers and class-based handlers.\n\n        Args:\n            path: URL pattern to match (may contain parameters)\n\n        Returns:\n            A decorator function that registers the handler\n\n        Example:\n            ```python\n            @app.route(\"/home\")\n            def home(request, response):\n                response.text = \"Hello, World!\"\n            ```\n\n            For class-based views:\n\n            ```python\n            @app.route(\"/books\")\n            class BooksResource:\n                def get(self, request, response):\n                    response.text = \"List of books\"\n            ```\n        \"\"\"\n\n        def wrapper(handler):\n            self.add_route(path, handler)\n            return handler\n\n        return wrapper\n\n    def __getattr__(\n        self,\n        name: str,\n    ):\n        \"\"\"\n        Enable HTTP method-specific decorators like app.get, app.post, etc.\n\n        This magic method is called when an attribute lookup fails, allowing\n        us to dynamically provide HTTP method decorators.\n\n        Args:\n            name: The attribute name being looked up\n\n        Returns:\n            A method-specific decorator function if name matches a HTTP method\n\n        Raises:\n            RuntimeError: If the attribute doesn't match a known HTTP method\n        \"\"\"\n        if name in self._method_decorators:\n            return self._method_decorators[name]\n        raise RuntimeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{name}'\"\n        )\n\n    def _create_method_decorator(self, method: HTTPMethods):\n        \"\"\"\n        Create a decorator for a specific HTTP method.\n\n        This internal method generates the decorators used for HTTP method-specific\n        route registration like @app.get(), @app.post(), etc.\n\n        Args:\n            method: The HTTP method enum value\n\n        Returns:\n            A decorator function for the specified HTTP method\n        \"\"\"\n\n        def decorator(path: str):\n            def wrapper(handler):\n                self.add_route(path, handler, method)\n                return handler\n\n            return wrapper\n\n        return decorator\n\n    def handle_request(\n        self,\n        request: Request,\n    ) -&gt; Response:\n        \"\"\"\n        Process an incoming request and generate a response.\n\n        This is the core request handling logic that finds a matching route handler,\n        executes it, and handles any exceptions.\n\n        Args:\n            request: The incoming WebOb Request object\n\n        Returns:\n            A Response object containing the response data\n        \"\"\"\n        response: Response = Response()\n\n        handler_definition, kwargs = self.find_handler(request, response)\n\n        try:\n            if handler_definition is not None:\n                method, handler = handler_definition\n\n                # Handle CBVs\n                if inspect.isclass(handler):\n                    handler = getattr(\n                        handler(),\n                        request.method.lower(),\n                        None,\n                    )\n                    # only allow methods that are defined in the class\n                    if handler is None:\n                        response.status_code = StatusCodes.METHOD_NOT_ALLOWED.value\n                        response.text = \"Method Not Allowed\"\n                        return response\n\n                if inspect.isfunction(handler):\n                    # Handle function-based views\n                    if request.method != method.value:\n                        response.status_code = StatusCodes.METHOD_NOT_ALLOWED.value\n                        response.text = \"Method Not Allowed\"\n                        return response\n\n                handler(request, response, **kwargs)\n\n        except Exception as e:\n            if self.exception_handler:\n                self.exception_handler(request, response, e)\n            else:\n                response.status_code = StatusCodes.INTERNAL_SERVER_ERROR.value\n                response.text = str(e)\n\n        return response\n\n    def find_handler(\n        self,\n        request: Request,\n        response: Response,\n    ) -&gt; Tuple[Tuple[HTTPMethods, Callable] | None, dict | None]:\n        \"\"\"\n        Find the appropriate handler for a request based on URL path matching.\n\n        This method iterates through registered routes and uses the parse library\n        to match URL patterns and extract parameters.\n\n        Args:\n            request: The incoming WebOb Request object\n            response: The Response object being built\n\n        Returns:\n            A tuple containing:\n                - The handler definition (method, handler) if found, or None\n                - A dictionary of extracted URL parameters, or None\n        \"\"\"\n        for path, handler in self.routes.items():\n            parse_result = parse(path, request.path)\n            if parse_result is not None:\n                return handler, parse_result.named\n\n        handle_404(response)\n        return None, None\n\n    def add_exception_handler(\n        self,\n        exception_handler,\n    ):\n        \"\"\"\n        Register a global exception handler for the application.\n\n        The exception handler will be called whenever an uncaught exception\n        occurs during request handling.\n\n        Args:\n            exception_handler: Callable that takes (request, response, exception)\n\n        Example:\n            ```python\n            def handle_exceptions(request, response, exception):\n                response.status_code = 500\n                response.text = f\"Error: {str(exception)}\"\n\n            app.add_exception_handler(handle_exceptions)\n            ```\n        \"\"\"\n        self.exception_handler = exception_handler\n\n    def add_middleware(\n        self,\n        middleware_cls: type[Middleware],\n    ):\n        \"\"\"\n        Add a middleware class to the application's middleware stack.\n\n        Middleware classes must inherit from the Middleware base class and can\n        process requests before they reach handlers and responses before they're returned.\n\n        Args:\n            middleware_cls: A class inheriting from Middleware\n\n        Example:\n            ```python\n            class SimpleMiddleware(Middleware):\n                def process_request(self, request):\n                    print(\"Processing request\")\n\n                def process_response(self, request, response):\n                    print(\"Processing response\")\n\n            app.add_middleware(SimpleMiddleware)\n            ```\n        \"\"\"\n        self.middleware.add(middleware_cls)\n\n    def test_session(self, base_url=\"http://testserver\"):\n        \"\"\"\n        Create a test client session for this application.\n\n        This provides an interface similar to the requests library for testing\n        your application without making actual HTTP calls.\n\n        Args:\n            base_url: Base URL to use for requests (default: \"http://testserver\")\n\n        Returns:\n            A requests.Session object configured to call this application\n\n        Example:\n            ```python\n            client = app.test_session()\n            response = client.get(\"/home\")\n            assert response.status_code == 200\n            ```\n        \"\"\"\n        session = RequestsSession()\n        session.mount(prefix=base_url, adapter=RequestsWSGIAdapter(self))\n        return session\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx-functions","title":"Functions","text":""},{"location":"api/applications/#plinx.applications.Plinx.__call__","title":"<code>__call__(environ, start_response)</code>","text":"<p>WSGI entry point for the application.</p> <p>This method makes the Plinx instance callable as required by the WSGI spec, allowing it to be used directly with WSGI servers like Gunicorn or uWSGI.</p> <p>Parameters:</p> Name Type Description Default <code>environ</code> <code>WSGIEnvironment</code> <p>The WSGI environment dictionary containing request information</p> required <code>start_response</code> <code>StartResponse</code> <p>The WSGI start_response callable</p> required <p>Returns:</p> Type Description <code>Iterable[bytes]</code> <p>An iterable of bytes representing the response body</p> Source code in <code>plinx/applications.py</code> <pre><code>def __call__(\n    self,\n    environ: WSGIEnvironment,\n    start_response: StartResponse,\n) -&gt; Iterable[bytes]:\n    \"\"\"\n    WSGI entry point for the application.\n\n    This method makes the Plinx instance callable as required by the WSGI spec,\n    allowing it to be used directly with WSGI servers like Gunicorn or uWSGI.\n\n    Args:\n        environ: The WSGI environment dictionary containing request information\n        start_response: The WSGI start_response callable\n\n    Returns:\n        An iterable of bytes representing the response body\n    \"\"\"\n    return self.middleware(environ, start_response)\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Enable HTTP method-specific decorators like app.get, app.post, etc.</p> <p>This magic method is called when an attribute lookup fails, allowing us to dynamically provide HTTP method decorators.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The attribute name being looked up</p> required <p>Returns:</p> Type Description <p>A method-specific decorator function if name matches a HTTP method</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the attribute doesn't match a known HTTP method</p> Source code in <code>plinx/applications.py</code> <pre><code>def __getattr__(\n    self,\n    name: str,\n):\n    \"\"\"\n    Enable HTTP method-specific decorators like app.get, app.post, etc.\n\n    This magic method is called when an attribute lookup fails, allowing\n    us to dynamically provide HTTP method decorators.\n\n    Args:\n        name: The attribute name being looked up\n\n    Returns:\n        A method-specific decorator function if name matches a HTTP method\n\n    Raises:\n        RuntimeError: If the attribute doesn't match a known HTTP method\n    \"\"\"\n    if name in self._method_decorators:\n        return self._method_decorators[name]\n    raise RuntimeError(\n        f\"'{self.__class__.__name__}' object has no attribute '{name}'\"\n    )\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new Plinx application instance.</p> <p>Sets up the routing table, middleware stack, and dynamically generates HTTP method-specific decorators.</p> Source code in <code>plinx/applications.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize a new Plinx application instance.\n\n    Sets up the routing table, middleware stack, and\n    dynamically generates HTTP method-specific decorators.\n    \"\"\"\n    self.routes: Dict[str, Tuple[HTTPMethods, Callable]] = {}\n    self.exception_handler = None\n    self.middleware = Middleware(self)\n\n    self._method_decorators = {}\n    for method in HTTPMethods:\n        self._method_decorators[method.name.lower()] = (\n            self._create_method_decorator(method)\n        )\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.add_exception_handler","title":"<code>add_exception_handler(exception_handler)</code>","text":"<p>Register a global exception handler for the application.</p> <p>The exception handler will be called whenever an uncaught exception occurs during request handling.</p> <p>Parameters:</p> Name Type Description Default <code>exception_handler</code> <p>Callable that takes (request, response, exception)</p> required Example <pre><code>def handle_exceptions(request, response, exception):\n    response.status_code = 500\n    response.text = f\"Error: {str(exception)}\"\n\napp.add_exception_handler(handle_exceptions)\n</code></pre> Source code in <code>plinx/applications.py</code> <pre><code>def add_exception_handler(\n    self,\n    exception_handler,\n):\n    \"\"\"\n    Register a global exception handler for the application.\n\n    The exception handler will be called whenever an uncaught exception\n    occurs during request handling.\n\n    Args:\n        exception_handler: Callable that takes (request, response, exception)\n\n    Example:\n        ```python\n        def handle_exceptions(request, response, exception):\n            response.status_code = 500\n            response.text = f\"Error: {str(exception)}\"\n\n        app.add_exception_handler(handle_exceptions)\n        ```\n    \"\"\"\n    self.exception_handler = exception_handler\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.add_middleware","title":"<code>add_middleware(middleware_cls)</code>","text":"<p>Add a middleware class to the application's middleware stack.</p> <p>Middleware classes must inherit from the Middleware base class and can process requests before they reach handlers and responses before they're returned.</p> <p>Parameters:</p> Name Type Description Default <code>middleware_cls</code> <code>type[Middleware]</code> <p>A class inheriting from Middleware</p> required Example <pre><code>class SimpleMiddleware(Middleware):\n    def process_request(self, request):\n        print(\"Processing request\")\n\n    def process_response(self, request, response):\n        print(\"Processing response\")\n\napp.add_middleware(SimpleMiddleware)\n</code></pre> Source code in <code>plinx/applications.py</code> <pre><code>def add_middleware(\n    self,\n    middleware_cls: type[Middleware],\n):\n    \"\"\"\n    Add a middleware class to the application's middleware stack.\n\n    Middleware classes must inherit from the Middleware base class and can\n    process requests before they reach handlers and responses before they're returned.\n\n    Args:\n        middleware_cls: A class inheriting from Middleware\n\n    Example:\n        ```python\n        class SimpleMiddleware(Middleware):\n            def process_request(self, request):\n                print(\"Processing request\")\n\n            def process_response(self, request, response):\n                print(\"Processing response\")\n\n        app.add_middleware(SimpleMiddleware)\n        ```\n    \"\"\"\n    self.middleware.add(middleware_cls)\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.add_route","title":"<code>add_route(path, handler, method=HTTPMethods.GET)</code>","text":"<p>Explicitly register a route with the application.</p> <p>This provides a Django-like syntax for registering routes, as an alternative to the decorator approach.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>URL pattern to match (may contain parameters)</p> required <code>handler</code> <code>Callable</code> <p>Function or class to handle matching requests</p> required <code>method</code> <code>HTTPMethods</code> <p>HTTP method to match (defaults to GET)</p> <code>GET</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the path is already registered</p> Example <pre><code>def home(request, response):\n    response.text = \"Hello, World!\"\n\napp.add_route(\"/home\", home)\n</code></pre> Source code in <code>plinx/applications.py</code> <pre><code>def add_route(\n    self,\n    path: str,\n    handler: Callable,\n    method: HTTPMethods = HTTPMethods.GET,\n):\n    \"\"\"\n    Explicitly register a route with the application.\n\n    This provides a Django-like syntax for registering routes,\n    as an alternative to the decorator approach.\n\n    Args:\n        path: URL pattern to match (may contain parameters)\n        handler: Function or class to handle matching requests\n        method: HTTP method to match (defaults to GET)\n\n    Raises:\n        RuntimeError: If the path is already registered\n\n    Example:\n        ```python\n        def home(request, response):\n            response.text = \"Hello, World!\"\n\n        app.add_route(\"/home\", home)\n        ```\n    \"\"\"\n    if path in self.routes:\n        raise RuntimeError(f\"Route '{path}' is already registered.\")\n\n    self.routes[path] = (method, handler)\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.find_handler","title":"<code>find_handler(request, response)</code>","text":"<p>Find the appropriate handler for a request based on URL path matching.</p> <p>This method iterates through registered routes and uses the parse library to match URL patterns and extract parameters.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming WebOb Request object</p> required <code>response</code> <code>PlinxResponse</code> <p>The Response object being built</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple[HTTPMethods, Callable] | None, dict | None]</code> <p>A tuple containing: - The handler definition (method, handler) if found, or None - A dictionary of extracted URL parameters, or None</p> Source code in <code>plinx/applications.py</code> <pre><code>def find_handler(\n    self,\n    request: Request,\n    response: Response,\n) -&gt; Tuple[Tuple[HTTPMethods, Callable] | None, dict | None]:\n    \"\"\"\n    Find the appropriate handler for a request based on URL path matching.\n\n    This method iterates through registered routes and uses the parse library\n    to match URL patterns and extract parameters.\n\n    Args:\n        request: The incoming WebOb Request object\n        response: The Response object being built\n\n    Returns:\n        A tuple containing:\n            - The handler definition (method, handler) if found, or None\n            - A dictionary of extracted URL parameters, or None\n    \"\"\"\n    for path, handler in self.routes.items():\n        parse_result = parse(path, request.path)\n        if parse_result is not None:\n            return handler, parse_result.named\n\n    handle_404(response)\n    return None, None\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.handle_request","title":"<code>handle_request(request)</code>","text":"<p>Process an incoming request and generate a response.</p> <p>This is the core request handling logic that finds a matching route handler, executes it, and handles any exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming WebOb Request object</p> required <p>Returns:</p> Type Description <code>PlinxResponse</code> <p>A Response object containing the response data</p> Source code in <code>plinx/applications.py</code> <pre><code>def handle_request(\n    self,\n    request: Request,\n) -&gt; Response:\n    \"\"\"\n    Process an incoming request and generate a response.\n\n    This is the core request handling logic that finds a matching route handler,\n    executes it, and handles any exceptions.\n\n    Args:\n        request: The incoming WebOb Request object\n\n    Returns:\n        A Response object containing the response data\n    \"\"\"\n    response: Response = Response()\n\n    handler_definition, kwargs = self.find_handler(request, response)\n\n    try:\n        if handler_definition is not None:\n            method, handler = handler_definition\n\n            # Handle CBVs\n            if inspect.isclass(handler):\n                handler = getattr(\n                    handler(),\n                    request.method.lower(),\n                    None,\n                )\n                # only allow methods that are defined in the class\n                if handler is None:\n                    response.status_code = StatusCodes.METHOD_NOT_ALLOWED.value\n                    response.text = \"Method Not Allowed\"\n                    return response\n\n            if inspect.isfunction(handler):\n                # Handle function-based views\n                if request.method != method.value:\n                    response.status_code = StatusCodes.METHOD_NOT_ALLOWED.value\n                    response.text = \"Method Not Allowed\"\n                    return response\n\n            handler(request, response, **kwargs)\n\n    except Exception as e:\n        if self.exception_handler:\n            self.exception_handler(request, response, e)\n        else:\n            response.status_code = StatusCodes.INTERNAL_SERVER_ERROR.value\n            response.text = str(e)\n\n    return response\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.route","title":"<code>route(path)</code>","text":"<p>Register a route via decorator syntax.</p> <p>This implements Flask-like syntax for registering routes. It can be used with both function-based handlers and class-based handlers.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>URL pattern to match (may contain parameters)</p> required <p>Returns:</p> Type Description <p>A decorator function that registers the handler</p> Example <pre><code>@app.route(\"/home\")\ndef home(request, response):\n    response.text = \"Hello, World!\"\n</code></pre> <p>For class-based views:</p> <pre><code>@app.route(\"/books\")\nclass BooksResource:\n    def get(self, request, response):\n        response.text = \"List of books\"\n</code></pre> Source code in <code>plinx/applications.py</code> <pre><code>def route(\n    self,\n    path: str,\n):\n    \"\"\"\n    Register a route via decorator syntax.\n\n    This implements Flask-like syntax for registering routes. It can be used\n    with both function-based handlers and class-based handlers.\n\n    Args:\n        path: URL pattern to match (may contain parameters)\n\n    Returns:\n        A decorator function that registers the handler\n\n    Example:\n        ```python\n        @app.route(\"/home\")\n        def home(request, response):\n            response.text = \"Hello, World!\"\n        ```\n\n        For class-based views:\n\n        ```python\n        @app.route(\"/books\")\n        class BooksResource:\n            def get(self, request, response):\n                response.text = \"List of books\"\n        ```\n    \"\"\"\n\n    def wrapper(handler):\n        self.add_route(path, handler)\n        return handler\n\n    return wrapper\n</code></pre>"},{"location":"api/applications/#plinx.applications.Plinx.test_session","title":"<code>test_session(base_url='http://testserver')</code>","text":"<p>Create a test client session for this application.</p> <p>This provides an interface similar to the requests library for testing your application without making actual HTTP calls.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <p>Base URL to use for requests (default: \"http://testserver\")</p> <code>'http://testserver'</code> <p>Returns:</p> Type Description <p>A requests.Session object configured to call this application</p> Example <pre><code>client = app.test_session()\nresponse = client.get(\"/home\")\nassert response.status_code == 200\n</code></pre> Source code in <code>plinx/applications.py</code> <pre><code>def test_session(self, base_url=\"http://testserver\"):\n    \"\"\"\n    Create a test client session for this application.\n\n    This provides an interface similar to the requests library for testing\n    your application without making actual HTTP calls.\n\n    Args:\n        base_url: Base URL to use for requests (default: \"http://testserver\")\n\n    Returns:\n        A requests.Session object configured to call this application\n\n    Example:\n        ```python\n        client = app.test_session()\n        response = client.get(\"/home\")\n        assert response.status_code == 200\n        ```\n    \"\"\"\n    session = RequestsSession()\n    session.mount(prefix=base_url, adapter=RequestsWSGIAdapter(self))\n    return session\n</code></pre>"},{"location":"api/applications/#example-usage","title":"Example Usage","text":""},{"location":"api/applications/#basic-application","title":"Basic Application","text":"<pre><code>from plinx import Plinx\n\napp = Plinx()\n\n@app.route(\"/\")\ndef home(request, response):\n    response.text = \"Hello, World!\"\n\n@app.route(\"/about\")\ndef about(request, response):\n    response.text = \"About page\"\n</code></pre>"},{"location":"api/applications/#http-method-specific-routes","title":"HTTP Method-Specific Routes","text":"<pre><code>@app.get(\"/api/items\")\ndef get_items(request, response):\n    response.json = {\"items\": [\"item1\", \"item2\"]}\n\n@app.post(\"/api/items\")\ndef create_item(request, response):\n    response.text = \"Item created\"\n    response.status_code = 201  # Created\n</code></pre>"},{"location":"api/applications/#dynamic-route-parameters","title":"Dynamic Route Parameters","text":"<pre><code>@app.route(\"/users/{user_id}\")\ndef get_user(request, response, user_id):\n    response.json = {\"user_id\": user_id, \"name\": f\"User {user_id}\"}\n</code></pre>"},{"location":"api/applications/#class-based-views","title":"Class-Based Views","text":"<pre><code>@app.route(\"/resources\")\nclass ResourceHandler:\n    def get(self, request, response):\n        response.json = {\"resources\": [\"res1\", \"res2\"]}\n\n    def post(self, request, response):\n        response.text = \"Resource created\"\n        response.status_code = 201\n</code></pre>"},{"location":"api/applications/#adding-middleware","title":"Adding Middleware","text":"<pre><code>from plinx.middleware import Middleware\n\nclass LoggingMiddleware(Middleware):\n    def process_request(self, request):\n        print(f\"Request: {request.method} {request.path}\")\n\n    def process_response(self, request, response):\n        print(f\"Response: {response.status_code}\")\n\napp = Plinx()\napp.add_middleware(LoggingMiddleware)\n</code></pre>"},{"location":"api/applications/#exception-handling","title":"Exception Handling","text":"<pre><code>def exception_handler(request, response, exception):\n    response.status_code = 500\n    response.json = {\n        \"error\": str(exception),\n        \"type\": exception.__class__.__name__\n    }\n\napp = Plinx()\napp.add_exception_handler(exception_handler)\n</code></pre>"},{"location":"api/applications/#running-with-a-wsgi-server","title":"Running with a WSGI Server","text":"<pre><code># app.py\nfrom plinx import Plinx\n\napp = Plinx()\n\n@app.route(\"/\")\ndef home(request, response):\n    response.text = \"Hello, World!\"\n</code></pre> <pre><code># Run with a WSGI server like Gunicorn\ngunicorn app:app\n</code></pre>"},{"location":"api/applications/#testing","title":"Testing","text":"<pre><code>app = Plinx()\n\n@app.route(\"/\")\ndef home(request, response):\n    response.text = \"Hello, World!\"\n\n# Create a test client\nclient = app.test_session()\n\n# Make requests\nresponse = client.get(\"/\")\nassert response.text == \"Hello, World!\"\nassert response.status_code == 200\n</code></pre>"},{"location":"api/methods/","title":"HTTP Methods API","text":"<p>The <code>methods</code> module defines constants and helper functions for handling HTTP methods in Plinx applications. This module provides a clean way to work with HTTP methods throughout your application.</p>"},{"location":"api/methods/#http-method-constants","title":"HTTP Method Constants","text":""},{"location":"api/methods/#plinx.methods.HTTPMethods","title":"<code>plinx.methods.HTTPMethods</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of HTTP methods supported by the Plinx framework.</p> <p>This enum defines the standard HTTP methods as defined in RFC 7231 and RFC 5789, categorized by their safety and idempotency properties.</p> <p>Safe methods (should not modify resources): - GET: Retrieve a representation of a resource - HEAD: Same as GET but returns only headers, no body</p> <p>Idempotent methods (multiple identical requests have same effect as single request): - PUT: Replace a resource with the request payload - DELETE: Remove the specified resource - OPTIONS: Describe the communication options for the target resource</p> <p>Non-idempotent methods (multiple identical requests may have different effects): - POST: Submit data to be processed, typically creating a new resource - PATCH: Apply partial modifications to a resource</p> Usage <pre><code>from plinx.methods import HTTPMethods\n\n# Check if a method is GET\nif method == HTTPMethods.GET:\n    # handle GET request\n\n# Get the string value of a method\nmethod_str = HTTPMethods.POST.value  # \"POST\"\n</code></pre> Source code in <code>plinx/methods.py</code> <pre><code>class HTTPMethods(Enum):\n    \"\"\"\n    Enumeration of HTTP methods supported by the Plinx framework.\n\n    This enum defines the standard HTTP methods as defined in RFC 7231 and RFC 5789,\n    categorized by their safety and idempotency properties.\n\n    Safe methods (should not modify resources):\n    - GET: Retrieve a representation of a resource\n    - HEAD: Same as GET but returns only headers, no body\n\n    Idempotent methods (multiple identical requests have same effect as single request):\n    - PUT: Replace a resource with the request payload\n    - DELETE: Remove the specified resource\n    - OPTIONS: Describe the communication options for the target resource\n\n    Non-idempotent methods (multiple identical requests may have different effects):\n    - POST: Submit data to be processed, typically creating a new resource\n    - PATCH: Apply partial modifications to a resource\n\n    Usage:\n        ```python\n        from plinx.methods import HTTPMethods\n\n        # Check if a method is GET\n        if method == HTTPMethods.GET:\n            # handle GET request\n\n        # Get the string value of a method\n        method_str = HTTPMethods.POST.value  # \"POST\"\n        ```\n    \"\"\"\n\n    # Safe methods\n    GET = \"GET\"\n    HEAD = \"HEAD\"\n\n    # Idempotent methods\n    PUT = \"PUT\"\n    DELETE = \"DELETE\"\n    OPTIONS = \"OPTIONS\"\n\n    # Non-idempotent methods\n    POST = \"POST\"\n    PATCH = \"PATCH\"\n</code></pre>"},{"location":"api/methods/#method-handling-functions","title":"Method Handling Functions","text":""},{"location":"api/methods/#plinx.methods.is_valid_method","title":"<code>plinx.methods.is_valid_method(method)</code>","text":"<p>Check if the given method is a valid HTTP method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the method is valid, False otherwise</p> Source code in <code>plinx/methods.py</code> <pre><code>def is_valid_method(method: str) -&gt; bool:\n    \"\"\"\n    Check if the given method is a valid HTTP method.\n\n    Args:\n        method: The HTTP method to check\n\n    Returns:\n        bool: True if the method is valid, False otherwise\n    \"\"\"\n    return method in HTTPMethods.__members__.values()\n</code></pre>"},{"location":"api/methods/#plinx.methods.get_handler_name_for_method","title":"<code>plinx.methods.get_handler_name_for_method(method)</code>","text":"<p>Get the handler name for a given HTTP method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to get the handler name for</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The handler name corresponding to the HTTP method</p> Source code in <code>plinx/methods.py</code> <pre><code>def get_handler_name_for_method(method: str) -&gt; str:\n    \"\"\"\n    Get the handler name for a given HTTP method.\n\n    Args:\n        method: The HTTP method to get the handler name for\n\n    Returns:\n        str: The handler name corresponding to the HTTP method\n    \"\"\"\n    if not is_valid_method(method):\n        raise ValueError(f\"Invalid HTTP method: {method}\")\n\n    return method.lower()\n</code></pre>"},{"location":"api/methods/#examples","title":"Examples","text":""},{"location":"api/methods/#checking-for-valid-http-methods","title":"Checking for Valid HTTP Methods","text":"<pre><code>from plinx.methods import is_valid_method\n\n# Check if a method is supported\nif is_valid_method(\"GET\"):\n    print(\"GET is a valid HTTP method\")\n\nif not is_valid_method(\"CUSTOM\"):\n    print(\"CUSTOM is not a valid HTTP method\")\n</code></pre>"},{"location":"api/methods/#working-with-http-method-constants","title":"Working with HTTP Method Constants","text":"<pre><code>from plinx import Plinx\nfrom plinx.methods import HTTPMethods\n\napp = Plinx()\n\n@app.route(\"/example\")\ndef handler(request, response):\n    if request.method == HTTPMethods.GET:\n        response.text = \"This is a GET request\"\n    elif request.method == HTTPMethods.POST:\n        response.text = \"This is a POST request\"\n    else:\n        response.text = f\"This is a {request.method} request\"\n</code></pre>"},{"location":"api/methods/#finding-handler-method-names","title":"Finding Handler Method Names","text":"<pre><code>from plinx.methods import get_handler_name_for_method\n\n# For class-based views, this function maps HTTP methods to method names\nhandler_name = get_handler_name_for_method(\"GET\")  # Returns \"get\"\nhandler_name = get_handler_name_for_method(\"POST\")  # Returns \"post\"\n</code></pre>"},{"location":"api/methods/#method-handling-in-class-based-views","title":"Method Handling in Class-Based Views","text":"<p>In class-based views, HTTP methods are automatically mapped to methods with lowercase names:</p> <pre><code>from plinx import Plinx\n\napp = Plinx()\n\n@app.route(\"/resource\")\nclass ResourceHandler:\n    def get(self, request, response):\n        response.text = \"Handling GET request\"\n\n    def post(self, request, response):\n        response.text = \"Handling POST request\"\n\n    def put(self, request, response):\n        response.text = \"Handling PUT request\"\n\n    def delete(self, request, response):\n        response.text = \"Handling DELETE request\"\n\n    def patch(self, request, response):\n        response.text = \"Handling PATCH request\"\n\n    def head(self, request, response):\n        # HEAD requests don't return a body\n        pass\n\n    def options(self, request, response):\n        response.headers[\"Allow\"] = \"GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS\"\n</code></pre> <p>When a request comes in, Plinx will call the appropriate method based on the HTTP method of the request.</p>"},{"location":"api/methods/#custom-method-handlers","title":"Custom Method Handlers","text":"<p>You can implement custom method handling by overriding the default behavior:</p> <pre><code>from plinx import Plinx\nfrom plinx.methods import get_handler_name_for_method\n\n# Custom function to map HTTP methods to handler names\ndef custom_method_mapper(method):\n    method_map = {\n        \"GET\": \"handle_get\",\n        \"POST\": \"handle_post\",\n        \"PUT\": \"handle_put\",\n        \"DELETE\": \"handle_delete\"\n    }\n    return method_map.get(method, \"handle_default\")\n\napp = Plinx()\n\n@app.route(\"/custom\")\nclass CustomMethodHandler:\n    def handle_get(self, request, response):\n        response.text = \"Custom GET handler\"\n\n    def handle_post(self, request, response):\n        response.text = \"Custom POST handler\"\n\n    def handle_put(self, request, response):\n        response.text = \"Custom PUT handler\"\n\n    def handle_delete(self, request, response):\n        response.text = \"Custom DELETE handler\"\n\n    def handle_default(self, request, response):\n        response.text = f\"Default handler for {request.method}\"\n\n    # Override the default method handling\n    def __getattr__(self, name):\n        if name == get_handler_name_for_method(request.method):\n            # Use our custom mapper instead\n            handler_name = custom_method_mapper(request.method)\n            return getattr(self, handler_name)\n        raise AttributeError(f\"{self.__class__.__name__} has no attribute {name}\")\n</code></pre>"},{"location":"api/methods/#method-not-allowed-handling","title":"Method Not Allowed Handling","text":"<p>Plinx automatically handles requests with methods not supported by your handler:</p> <pre><code>from plinx import Plinx\n\napp = Plinx()\n\n@app.route(\"/limited\")\nclass LimitedHandler:\n    def get(self, request, response):\n        response.text = \"GET is allowed\"\n\n    # No other methods defined\n    # POST, PUT, etc. will receive a 405 Method Not Allowed response\n\n# For function handlers, the default behavior allows all methods\n@app.route(\"/allow-all\")\ndef all_methods_handler(request, response):\n    response.text = f\"Handling {request.method} request\"\n</code></pre>"},{"location":"api/methods/#method-override","title":"Method Override","text":"<p>Sometimes it's useful to override the HTTP method, especially when working with HTML forms that only support GET and POST:</p> <pre><code>from plinx import Plinx\nfrom plinx.middleware import Middleware\n\nclass MethodOverrideMiddleware(Middleware):\n    def process_request(self, request):\n        # Check for X-HTTP-Method-Override header\n        override = request.headers.get(\"X-HTTP-Method-Override\")\n\n        # Check for _method form field (common in HTML forms)\n        if not override and request.method == \"POST\":\n            override = request.POST.get(\"_method\")\n\n        # Override the method if specified\n        if override and override.upper() in [\"PUT\", \"DELETE\", \"PATCH\"]:\n            request.method = override.upper()\n\napp = Plinx()\napp.add_middleware(MethodOverrideMiddleware)\n</code></pre> <p>This allows HTML forms to simulate PUT, DELETE, and PATCH requests by including a form field named <code>_method</code> or by setting the <code>X-HTTP-Method-Override</code> header.</p>"},{"location":"api/methods/#best-practices","title":"Best Practices","text":"<ol> <li>Use HTTP methods semantically: Follow RESTful conventions (GET for retrieval, POST for creation, etc.)</li> <li>Handle OPTIONS requests: Especially important for CORS support</li> <li>Return appropriate status codes: 405 Method Not Allowed for unsupported methods</li> <li>Support idempotent methods: GET, PUT, and DELETE should be idempotent</li> <li>Consider method overrides: If supporting HTML forms that can only use GET and POST</li> <li>Document supported methods: Make it clear which methods are supported by each endpoint</li> </ol>"},{"location":"api/middleware/","title":"Middleware API","text":"<p>The <code>middleware</code> module defines the middleware system for Plinx applications. Middleware components process requests before they reach handlers and responses before they're returned to clients.</p>"},{"location":"api/middleware/#middleware-class","title":"Middleware Class","text":""},{"location":"api/middleware/#plinx.middleware.Middleware","title":"<code>plinx.middleware.Middleware</code>","text":"<p>Base class for all Plinx middleware components.</p> <p>The middleware system in Plinx follows a nested pattern where each middleware wraps the application or another middleware component. This allows for a chain of processing both before a request reaches the application and after the application generates a response.</p> <p>Middleware classes should inherit from this base class and override the <code>process_request</code> and <code>process_response</code> methods to implement custom behavior.</p> <p>The middleware execution flow works like this: 1. Client request comes in 2. Each middleware's <code>process_request</code> is called from outermost to innermost 3. The application handles the request 4. Each middleware's <code>process_response</code> is called from innermost to outermost 5. The response is sent back to the client</p> <p>Examples:</p> <pre><code>class LoggingMiddleware(Middleware):\n    def process_request(self, request):\n        print(f\"Request: {request.path}\")\n\n    def process_response(self, request, response):\n        print(f\"Response: {response.status_code}\")\n\napp = Plinx()\napp.add_middleware(LoggingMiddleware)\n</code></pre> <p>Middleware that modifies the request or response:</p> <pre><code>class AuthMiddleware(Middleware):\n    def process_request(self, request):\n        request.user = None\n        auth_header = request.headers.get(\"Authorization\", \"\")\n        if auth_header.startswith(\"Bearer \"):\n            token = auth_header[7:]\n            request.user = self.get_user_from_token(token)\n\n    def get_user_from_token(self, token):\n        # Implementation to validate token and return user\n        pass\n</code></pre> Source code in <code>plinx/middleware.py</code> <pre><code>class Middleware:\n    \"\"\"\n    Base class for all Plinx middleware components.\n\n    The middleware system in Plinx follows a nested pattern where each middleware\n    wraps the application or another middleware component. This allows for a chain\n    of processing both before a request reaches the application and after the\n    application generates a response.\n\n    Middleware classes should inherit from this base class and override the\n    `process_request` and `process_response` methods to implement custom behavior.\n\n    The middleware execution flow works like this:\n    1. Client request comes in\n    2. Each middleware's `process_request` is called from outermost to innermost\n    3. The application handles the request\n    4. Each middleware's `process_response` is called from innermost to outermost\n    5. The response is sent back to the client\n\n    Examples:\n        ```python\n        class LoggingMiddleware(Middleware):\n            def process_request(self, request):\n                print(f\"Request: {request.path}\")\n\n            def process_response(self, request, response):\n                print(f\"Response: {response.status_code}\")\n\n        app = Plinx()\n        app.add_middleware(LoggingMiddleware)\n        ```\n\n        Middleware that modifies the request or response:\n\n        ```python\n        class AuthMiddleware(Middleware):\n            def process_request(self, request):\n                request.user = None\n                auth_header = request.headers.get(\"Authorization\", \"\")\n                if auth_header.startswith(\"Bearer \"):\n                    token = auth_header[7:]\n                    request.user = self.get_user_from_token(token)\n\n            def get_user_from_token(self, token):\n                # Implementation to validate token and return user\n                pass\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        app,\n    ):\n        \"\"\"\n        Initialize the middleware with a WSGI application.\n\n        Args:\n            app: A WSGI application (typically a Plinx instance or another middleware)\n        \"\"\"\n        self.app = app\n\n    def __call__(\n        self,\n        environ: dict,\n        start_response: callable,\n    ):\n        \"\"\"\n        WSGI callable interface for the middleware.\n\n        This method makes middleware instances callable according to the WSGI spec,\n        allowing them to be used in a WSGI server. It creates a Request object,\n        passes it to the application's handle_request method, and returns the\n        response.\n\n        Args:\n            environ: The WSGI environment dictionary\n            start_response: The WSGI start_response callable\n\n        Returns:\n            An iterable of bytes representing the response body\n        \"\"\"\n        request = Request(environ)\n\n        response = self.app.handle_request(request)\n\n        return response(environ, start_response)\n\n    def add(\n        self,\n        middleware_cls,\n    ):\n        \"\"\"\n        Add a new middleware to the stack.\n\n        This method creates an instance of the provided middleware class,\n        passing the current middleware instance (or application) as the app parameter.\n        This builds up a chain of nested middleware instances.\n\n        Args:\n            middleware_cls: A class inheriting from Middleware\n        \"\"\"\n        self.app = middleware_cls(self.app)\n\n    def process_request(\n        self,\n        request: Request,\n    ):\n        \"\"\"\n        Process the request before it reaches the application.\n\n        Override this method in your middleware subclass to modify or inspect\n        the request before it's handled by the application or the next middleware.\n\n        Args:\n            request: The WebOb Request object\n        \"\"\"\n        pass  # pragma: no cover\n\n    def process_response(\n        self,\n        request: Request,\n        response: Response,\n    ):\n        \"\"\"\n        Process the response after it's generated by the application.\n\n        Override this method in your middleware subclass to modify or inspect\n        the response before it's returned to the client or the previous middleware.\n\n        Args:\n            request: The WebOb Request object that generated this response\n            response: The Response object to be returned\n        \"\"\"\n        pass  # pragma: no cover\n\n    def handle_request(self, request: Request):\n        \"\"\"\n        Process a request through this middleware and the wrapped application.\n\n        This method implements the middleware chain by:\n        1. Calling this middleware's process_request method\n        2. Passing the request to the wrapped application/middleware\n        3. Calling this middleware's process_response method with the response\n\n        Args:\n            request: The WebOb Request object\n\n        Returns:\n            The Response object after processing\n        \"\"\"\n        self.process_request(request)\n        response = self.app.handle_request(request)\n        self.process_response(request, response)\n\n        return response\n</code></pre>"},{"location":"api/middleware/#plinx.middleware.Middleware-functions","title":"Functions","text":""},{"location":"api/middleware/#plinx.middleware.Middleware.__call__","title":"<code>__call__(environ, start_response)</code>","text":"<p>WSGI callable interface for the middleware.</p> <p>This method makes middleware instances callable according to the WSGI spec, allowing them to be used in a WSGI server. It creates a Request object, passes it to the application's handle_request method, and returns the response.</p> <p>Parameters:</p> Name Type Description Default <code>environ</code> <code>dict</code> <p>The WSGI environment dictionary</p> required <code>start_response</code> <code>callable</code> <p>The WSGI start_response callable</p> required <p>Returns:</p> Type Description <p>An iterable of bytes representing the response body</p> Source code in <code>plinx/middleware.py</code> <pre><code>def __call__(\n    self,\n    environ: dict,\n    start_response: callable,\n):\n    \"\"\"\n    WSGI callable interface for the middleware.\n\n    This method makes middleware instances callable according to the WSGI spec,\n    allowing them to be used in a WSGI server. It creates a Request object,\n    passes it to the application's handle_request method, and returns the\n    response.\n\n    Args:\n        environ: The WSGI environment dictionary\n        start_response: The WSGI start_response callable\n\n    Returns:\n        An iterable of bytes representing the response body\n    \"\"\"\n    request = Request(environ)\n\n    response = self.app.handle_request(request)\n\n    return response(environ, start_response)\n</code></pre>"},{"location":"api/middleware/#plinx.middleware.Middleware.__init__","title":"<code>__init__(app)</code>","text":"<p>Initialize the middleware with a WSGI application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <p>A WSGI application (typically a Plinx instance or another middleware)</p> required Source code in <code>plinx/middleware.py</code> <pre><code>def __init__(\n    self,\n    app,\n):\n    \"\"\"\n    Initialize the middleware with a WSGI application.\n\n    Args:\n        app: A WSGI application (typically a Plinx instance or another middleware)\n    \"\"\"\n    self.app = app\n</code></pre>"},{"location":"api/middleware/#plinx.middleware.Middleware.add","title":"<code>add(middleware_cls)</code>","text":"<p>Add a new middleware to the stack.</p> <p>This method creates an instance of the provided middleware class, passing the current middleware instance (or application) as the app parameter. This builds up a chain of nested middleware instances.</p> <p>Parameters:</p> Name Type Description Default <code>middleware_cls</code> <p>A class inheriting from Middleware</p> required Source code in <code>plinx/middleware.py</code> <pre><code>def add(\n    self,\n    middleware_cls,\n):\n    \"\"\"\n    Add a new middleware to the stack.\n\n    This method creates an instance of the provided middleware class,\n    passing the current middleware instance (or application) as the app parameter.\n    This builds up a chain of nested middleware instances.\n\n    Args:\n        middleware_cls: A class inheriting from Middleware\n    \"\"\"\n    self.app = middleware_cls(self.app)\n</code></pre>"},{"location":"api/middleware/#plinx.middleware.Middleware.handle_request","title":"<code>handle_request(request)</code>","text":"<p>Process a request through this middleware and the wrapped application.</p> <p>This method implements the middleware chain by: 1. Calling this middleware's process_request method 2. Passing the request to the wrapped application/middleware 3. Calling this middleware's process_response method with the response</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The WebOb Request object</p> required <p>Returns:</p> Type Description <p>The Response object after processing</p> Source code in <code>plinx/middleware.py</code> <pre><code>def handle_request(self, request: Request):\n    \"\"\"\n    Process a request through this middleware and the wrapped application.\n\n    This method implements the middleware chain by:\n    1. Calling this middleware's process_request method\n    2. Passing the request to the wrapped application/middleware\n    3. Calling this middleware's process_response method with the response\n\n    Args:\n        request: The WebOb Request object\n\n    Returns:\n        The Response object after processing\n    \"\"\"\n    self.process_request(request)\n    response = self.app.handle_request(request)\n    self.process_response(request, response)\n\n    return response\n</code></pre>"},{"location":"api/middleware/#plinx.middleware.Middleware.process_request","title":"<code>process_request(request)</code>","text":"<p>Process the request before it reaches the application.</p> <p>Override this method in your middleware subclass to modify or inspect the request before it's handled by the application or the next middleware.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The WebOb Request object</p> required Source code in <code>plinx/middleware.py</code> <pre><code>def process_request(\n    self,\n    request: Request,\n):\n    \"\"\"\n    Process the request before it reaches the application.\n\n    Override this method in your middleware subclass to modify or inspect\n    the request before it's handled by the application or the next middleware.\n\n    Args:\n        request: The WebOb Request object\n    \"\"\"\n    pass  # pragma: no cover\n</code></pre>"},{"location":"api/middleware/#plinx.middleware.Middleware.process_response","title":"<code>process_response(request, response)</code>","text":"<p>Process the response after it's generated by the application.</p> <p>Override this method in your middleware subclass to modify or inspect the response before it's returned to the client or the previous middleware.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The WebOb Request object that generated this response</p> required <code>response</code> <code>Response</code> <p>The Response object to be returned</p> required Source code in <code>plinx/middleware.py</code> <pre><code>def process_response(\n    self,\n    request: Request,\n    response: Response,\n):\n    \"\"\"\n    Process the response after it's generated by the application.\n\n    Override this method in your middleware subclass to modify or inspect\n    the response before it's returned to the client or the previous middleware.\n\n    Args:\n        request: The WebOb Request object that generated this response\n        response: The Response object to be returned\n    \"\"\"\n    pass  # pragma: no cover\n</code></pre>"},{"location":"api/middleware/#custom-middleware-examples","title":"Custom Middleware Examples","text":""},{"location":"api/middleware/#simple-logging-middleware","title":"Simple Logging Middleware","text":"<pre><code>from plinx.middleware import Middleware\n\nclass LoggingMiddleware(Middleware):\n    def process_request(self, request):\n        print(f\"Incoming request: {request.method} {request.path}\")\n\n    def process_response(self, request, response):\n        print(f\"Outgoing response: {response.status_code}\")\n</code></pre>"},{"location":"api/middleware/#request-timer-middleware","title":"Request Timer Middleware","text":"<pre><code>import time\nfrom plinx.middleware import Middleware\n\nclass TimerMiddleware(Middleware):\n    def process_request(self, request):\n        request.start_time = time.time()\n\n    def process_response(self, request, response):\n        if hasattr(request, \"start_time\"):\n            duration = time.time() - request.start_time\n            print(f\"Request took {duration:.6f} seconds\")\n            # Add timing header\n            response.headers[\"X-Request-Duration\"] = f\"{duration:.6f}\"\n</code></pre>"},{"location":"api/middleware/#authentication-middleware","title":"Authentication Middleware","text":"<pre><code>from plinx.middleware import Middleware\n\nclass AuthMiddleware(Middleware):\n    def process_request(self, request):\n        request.user = None\n\n        # Check for authentication header\n        auth_header = request.headers.get(\"Authorization\", \"\")\n        if auth_header.startswith(\"Bearer \"):\n            token = auth_header[7:]\n            try:\n                # In a real app, you'd verify the token\n                user_id = self.verify_token(token)\n                request.user = {\"id\": user_id}\n            except Exception as e:\n                print(f\"Auth error: {str(e)}\")\n\n    def verify_token(self, token):\n        # Simplified demo - in reality, you'd verify with your auth system\n        if token == \"valid_demo_token\":\n            return 1\n        raise Exception(\"Invalid token\")\n</code></pre>"},{"location":"api/middleware/#cors-middleware","title":"CORS Middleware","text":"<pre><code>from plinx.middleware import Middleware\n\nclass CORSMiddleware(Middleware):\n    def __init__(self, app, allowed_origins=None):\n        super().__init__(app)\n        self.allowed_origins = allowed_origins or [\"*\"]\n\n    def process_response(self, request, response):\n        origin = request.headers.get(\"Origin\", \"\")\n\n        # Check if the origin is allowed\n        if \"*\" in self.allowed_origins or origin in self.allowed_origins:\n            response.headers[\"Access-Control-Allow-Origin\"] = origin\n            response.headers[\"Access-Control-Allow-Methods\"] = \"GET, POST, PUT, DELETE, OPTIONS\"\n            response.headers[\"Access-Control-Allow-Headers\"] = \"Content-Type, Authorization\"\n\n        # Handle preflight OPTIONS requests\n        if request.method == \"OPTIONS\":\n            response.status_code = 200\n            return response\n</code></pre>"},{"location":"api/middleware/#using-multiple-middleware","title":"Using Multiple Middleware","text":"<p>You can add multiple middleware components to a Plinx application:</p> <pre><code>from plinx import Plinx\nfrom plinx.middleware import Middleware\n\nclass Middleware1(Middleware):\n    def process_request(self, request):\n        print(\"Middleware 1: process_request\")\n\n    def process_response(self, request, response):\n        print(\"Middleware 1: process_response\")\n\nclass Middleware2(Middleware):\n    def process_request(self, request):\n        print(\"Middleware 2: process_request\")\n\n    def process_response(self, request, response):\n        print(\"Middleware 2: process_response\")\n\napp = Plinx()\n\n# Order matters! Middleware1 will be called before Middleware2 for requests,\n# but after Middleware2 for responses\napp.add_middleware(Middleware1)\napp.add_middleware(Middleware2)\n</code></pre> <p>This will produce the following execution order for a request: 1. Middleware1.process_request 2. Middleware2.process_request 3. Handler processes the request 4. Middleware2.process_response 5. Middleware1.process_response</p>"},{"location":"api/middleware/#short-circuiting-requests","title":"Short-Circuiting Requests","text":"<p>A middleware can short-circuit the request processing by returning a response:</p> <pre><code>from plinx.middleware import Middleware\nfrom plinx.status_codes import StatusCodes\n\nclass AuthRequiredMiddleware(Middleware):\n    def process_request(self, request):\n        auth_header = request.headers.get(\"Authorization\", \"\")\n\n        # If no auth header, short-circuit the request\n        if not auth_header:\n            # Need to access the app to create a response\n            response = self.app.handle_request(request)\n            response.status_code = StatusCodes.UNAUTHORIZED.value\n            response.json = {\"error\": \"Authentication required\"}\n            return response  # Short-circuit\n</code></pre>"},{"location":"api/middleware/#error-handling-in-middleware","title":"Error Handling in Middleware","text":"<pre><code>from plinx.middleware import Middleware\nfrom plinx.status_codes import StatusCodes\n\nclass ErrorCatchingMiddleware(Middleware):\n    def process_request(self, request):\n        try:\n            # Normal request processing\n            pass\n        except Exception as e:\n            print(f\"Request error: {str(e)}\")\n\n    def process_response(self, request, response):\n        # You can modify the response based on conditions\n        if response.status_code &gt;= 500:\n            response.json = {\n                \"error\": \"An internal error occurred\",\n                \"status_code\": response.status_code\n            }\n            # Log the error\n            print(f\"Server error occurred: {response.status_code}\")\n</code></pre>"},{"location":"api/orm/","title":"ORM API","text":"<p>The Plinx ORM (Object-Relational Mapping) module provides a lightweight interface for working with SQLite databases. This page documents the core classes and methods available in the ORM.</p>"},{"location":"api/orm/#database-class","title":"Database Class","text":""},{"location":"api/orm/#plinx.orm.orm.Database","title":"<code>plinx.orm.orm.Database</code>","text":"<p>SQLite database wrapper that provides a simple ORM interface.</p> <p>The Database class is the main entry point for ORM operations in Plinx. It handles database connections, table creation, and provides methods for basic CRUD operations (Create, Read, Update, Delete) on Table objects.</p> <p>This class uses SQLite as the underlying database engine and provides a simplified interface that avoids writing raw SQL in most cases.</p> <p>Examples:</p> <p>Creating a database and defining models:</p> <pre><code>from plinx.orm import Database, Table, Column, ForeignKey\n\ndb = Database(\"app.db\")\n\nclass User(Table):\n    name = Column(str)\n    age = Column(int)\n\ndb.create(User)\n\n# Create a new user\njohn = User(name=\"John Doe\", age=30)\ndb.save(john)\n\n# Query users\nall_users = db.all(User)\njohn = db.get(User, id=1)\n\n# Update a user\njohn.age = 31\ndb.update(john)\n\n# Delete a user\ndb.delete(john)\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>class Database:\n    \"\"\"\n    SQLite database wrapper that provides a simple ORM interface.\n\n    The Database class is the main entry point for ORM operations in Plinx.\n    It handles database connections, table creation, and provides methods for\n    basic CRUD operations (Create, Read, Update, Delete) on Table objects.\n\n    This class uses SQLite as the underlying database engine and provides\n    a simplified interface that avoids writing raw SQL in most cases.\n\n    Examples:\n        Creating a database and defining models:\n\n        ```python\n        from plinx.orm import Database, Table, Column, ForeignKey\n\n        db = Database(\"app.db\")\n\n        class User(Table):\n            name = Column(str)\n            age = Column(int)\n\n        db.create(User)\n\n        # Create a new user\n        john = User(name=\"John Doe\", age=30)\n        db.save(john)\n\n        # Query users\n        all_users = db.all(User)\n        john = db.get(User, id=1)\n\n        # Update a user\n        john.age = 31\n        db.update(john)\n\n        # Delete a user\n        db.delete(john)\n        ```\n    \"\"\"\n\n    def __init__(self, path: str):\n        \"\"\"\n        Initialize a new database connection.\n\n        Args:\n            path: Path to the SQLite database file. If the file doesn't exist,\n                 it will be created.\n        \"\"\"\n        self.connection = sqlite3.Connection(path)\n\n    def create(self, table: \"Table\"):\n        \"\"\"\n        Create a database table based on a Table subclass definition.\n\n        This method creates a table in the database with columns corresponding\n        to the Column and ForeignKey attributes defined on the Table subclass.\n        If the table already exists, this method does nothing.\n\n        Args:\n            table: A Table subclass with Column and/or ForeignKey attributes\n\n        Example:\n            ```python\n            class User(Table):\n                name = Column(str)\n                age = Column(int)\n\n            db.create(User)\n            ```\n        \"\"\"\n        self.connection.execute(table._get_create_sql())\n\n    def save(self, instance: \"Table\"):\n        \"\"\"\n        Save a Table instance to the database.\n\n        This method inserts a new row into the corresponding database table.\n        It automatically sets the instance's id attribute to the new row's ID.\n\n        Args:\n            instance: A Table instance to save\n\n        Example:\n            ```python\n            user = User(name=\"John Doe\", age=30)\n            db.save(user)  # user.id is now set to the new row's ID\n            ```\n        \"\"\"\n        sql, values = instance._get_insert_sql()\n        cursor = self.connection.execute(sql, values)\n        instance._data[\"id\"] = cursor.lastrowid\n        self.connection.commit()\n\n    def all(self, table: \"Table\"):\n        \"\"\"\n        Retrieve all rows from a table.\n\n        This method selects all rows from the table corresponding to the given\n        Table subclass. It returns a list of instances of that class, with\n        attributes set to the values from the database.\n\n        Args:\n            table: A Table subclass to query\n\n        Returns:\n            List of Table instances, one for each row in the table\n\n        Example:\n            ```python\n            all_users = db.all(User)\n            for user in all_users:\n                print(f\"{user.name} is {user.age} years old\")\n            ```\n        \"\"\"\n        sql, fields = table._get_select_all_sql()\n        rows = self.connection.execute(sql).fetchall()\n\n        result = []\n\n        for row in rows:\n            properties = {}\n            for field, value in zip(fields, row):\n                if field.endswith(\"_id\"):\n                    foreign_key = field[:-3]\n                    foreign_table = getattr(table, foreign_key).table\n                    properties[foreign_key] = self.get(foreign_table, id=value)\n                else:\n                    properties[field] = value\n            result.append(table(**properties))\n\n        return result\n\n    def get(self, table: \"Table\", **kwargs):\n        \"\"\"\n        Retrieve a single row from a table by specified criteria.\n\n        This method selects a row from the database where the specified columns\n        match the given values. It returns an instance of the Table subclass with\n        attributes set to the values from the database.\n\n        Args:\n            table: A Table subclass to query\n            **kwargs: Column-value pairs to filter by\n\n        Returns:\n            A Table instance corresponding to the matched row\n\n        Raises:\n            Exception: If no row matches the criteria\n\n        Example:\n            ```python\n            # Get user by ID\n            user = db.get(User, id=1)\n\n            # Get user by name\n            user = db.get(User, name=\"John Doe\")\n            ```\n        \"\"\"\n        sql, fields, params = table._get_select_where_sql(**kwargs)\n        row = self.connection.execute(sql, params).fetchone()\n\n        if row is None:\n            raise Exception(f\"{table.__name__} instance with {kwargs} does not exist\")\n\n        properties = {}\n\n        for field, value in zip(fields, row):\n            if field.endswith(\"_id\"):\n                foreign_key = field[:-3]\n                foreign_table = getattr(table, foreign_key).table\n                properties[foreign_key] = self.get(foreign_table, id=value)\n            else:\n                properties[field] = value\n\n        return table(**properties)\n\n    def update(self, instance: \"Table\"):\n        \"\"\"\n        Update an existing row in the database.\n\n        This method updates the row corresponding to the given instance with the\n        current values of the instance's attributes.\n\n        Args:\n            instance: A Table instance to update. Must have an id attribute.\n\n        Example:\n            ```python\n            user = db.get(User, id=1)\n            user.name = \"Jane Doe\"\n            db.update(user)\n            ```\n        \"\"\"\n        sql, values = instance._get_update_sql()\n        self.connection.execute(sql, values)\n        self.connection.commit()\n\n    def delete(self, instance: \"Table\"):\n        \"\"\"\n        Delete a row from the database.\n\n        This method deletes the row corresponding to the given instance.\n\n        Args:\n            instance: A Table instance to delete. Must have an id attribute.\n\n        Example:\n            ```python\n            user = db.get(User, id=1)\n            db.delete(user)\n            ```\n        \"\"\"\n        sql, values = instance._get_delete_sql()\n        self.connection.execute(sql, values)\n        self.connection.commit()\n\n    def close(self):\n        \"\"\"\n        Close the database connection.\n\n        This method closes the SQLite connection when the database is no longer\n        needed. It's good practice to call this method when you're done using\n        the database, especially in longer-running applications.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n        self.connection = None\n\n    @property\n    def tables(self):\n        \"\"\"\n        Get a list of all tables in the database.\n\n        Returns:\n            List of table names as strings\n        \"\"\"\n        SELECT_TABLES_SQL = \"SELECT name FROM sqlite_master WHERE type = 'table';\"\n        return [x[0] for x in self.connection.execute(SELECT_TABLES_SQL).fetchall()]\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Database-attributes","title":"Attributes","text":""},{"location":"api/orm/#plinx.orm.orm.Database.tables","title":"<code>tables</code>  <code>property</code>","text":"<p>Get a list of all tables in the database.</p> <p>Returns:</p> Type Description <p>List of table names as strings</p>"},{"location":"api/orm/#plinx.orm.orm.Database-functions","title":"Functions","text":""},{"location":"api/orm/#plinx.orm.orm.Database.__init__","title":"<code>__init__(path)</code>","text":"<p>Initialize a new database connection.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the SQLite database file. If the file doesn't exist,  it will be created.</p> required Source code in <code>plinx/orm/orm.py</code> <pre><code>def __init__(self, path: str):\n    \"\"\"\n    Initialize a new database connection.\n\n    Args:\n        path: Path to the SQLite database file. If the file doesn't exist,\n             it will be created.\n    \"\"\"\n    self.connection = sqlite3.Connection(path)\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Database.all","title":"<code>all(table)</code>","text":"<p>Retrieve all rows from a table.</p> <p>This method selects all rows from the table corresponding to the given Table subclass. It returns a list of instances of that class, with attributes set to the values from the database.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> <p>A Table subclass to query</p> required <p>Returns:</p> Type Description <p>List of Table instances, one for each row in the table</p> Example <pre><code>all_users = db.all(User)\nfor user in all_users:\n    print(f\"{user.name} is {user.age} years old\")\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>def all(self, table: \"Table\"):\n    \"\"\"\n    Retrieve all rows from a table.\n\n    This method selects all rows from the table corresponding to the given\n    Table subclass. It returns a list of instances of that class, with\n    attributes set to the values from the database.\n\n    Args:\n        table: A Table subclass to query\n\n    Returns:\n        List of Table instances, one for each row in the table\n\n    Example:\n        ```python\n        all_users = db.all(User)\n        for user in all_users:\n            print(f\"{user.name} is {user.age} years old\")\n        ```\n    \"\"\"\n    sql, fields = table._get_select_all_sql()\n    rows = self.connection.execute(sql).fetchall()\n\n    result = []\n\n    for row in rows:\n        properties = {}\n        for field, value in zip(fields, row):\n            if field.endswith(\"_id\"):\n                foreign_key = field[:-3]\n                foreign_table = getattr(table, foreign_key).table\n                properties[foreign_key] = self.get(foreign_table, id=value)\n            else:\n                properties[field] = value\n        result.append(table(**properties))\n\n    return result\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Database.close","title":"<code>close()</code>","text":"<p>Close the database connection.</p> <p>This method closes the SQLite connection when the database is no longer needed. It's good practice to call this method when you're done using the database, especially in longer-running applications.</p> Source code in <code>plinx/orm/orm.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the database connection.\n\n    This method closes the SQLite connection when the database is no longer\n    needed. It's good practice to call this method when you're done using\n    the database, especially in longer-running applications.\n    \"\"\"\n    if self.connection:\n        self.connection.close()\n    self.connection = None\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Database.create","title":"<code>create(table)</code>","text":"<p>Create a database table based on a Table subclass definition.</p> <p>This method creates a table in the database with columns corresponding to the Column and ForeignKey attributes defined on the Table subclass. If the table already exists, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> <p>A Table subclass with Column and/or ForeignKey attributes</p> required Example <pre><code>class User(Table):\n    name = Column(str)\n    age = Column(int)\n\ndb.create(User)\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>def create(self, table: \"Table\"):\n    \"\"\"\n    Create a database table based on a Table subclass definition.\n\n    This method creates a table in the database with columns corresponding\n    to the Column and ForeignKey attributes defined on the Table subclass.\n    If the table already exists, this method does nothing.\n\n    Args:\n        table: A Table subclass with Column and/or ForeignKey attributes\n\n    Example:\n        ```python\n        class User(Table):\n            name = Column(str)\n            age = Column(int)\n\n        db.create(User)\n        ```\n    \"\"\"\n    self.connection.execute(table._get_create_sql())\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Database.delete","title":"<code>delete(instance)</code>","text":"<p>Delete a row from the database.</p> <p>This method deletes the row corresponding to the given instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Table</code> <p>A Table instance to delete. Must have an id attribute.</p> required Example <pre><code>user = db.get(User, id=1)\ndb.delete(user)\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>def delete(self, instance: \"Table\"):\n    \"\"\"\n    Delete a row from the database.\n\n    This method deletes the row corresponding to the given instance.\n\n    Args:\n        instance: A Table instance to delete. Must have an id attribute.\n\n    Example:\n        ```python\n        user = db.get(User, id=1)\n        db.delete(user)\n        ```\n    \"\"\"\n    sql, values = instance._get_delete_sql()\n    self.connection.execute(sql, values)\n    self.connection.commit()\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Database.get","title":"<code>get(table, **kwargs)</code>","text":"<p>Retrieve a single row from a table by specified criteria.</p> <p>This method selects a row from the database where the specified columns match the given values. It returns an instance of the Table subclass with attributes set to the values from the database.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> <p>A Table subclass to query</p> required <code>**kwargs</code> <p>Column-value pairs to filter by</p> <code>{}</code> <p>Returns:</p> Type Description <p>A Table instance corresponding to the matched row</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no row matches the criteria</p> Example <pre><code># Get user by ID\nuser = db.get(User, id=1)\n\n# Get user by name\nuser = db.get(User, name=\"John Doe\")\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>def get(self, table: \"Table\", **kwargs):\n    \"\"\"\n    Retrieve a single row from a table by specified criteria.\n\n    This method selects a row from the database where the specified columns\n    match the given values. It returns an instance of the Table subclass with\n    attributes set to the values from the database.\n\n    Args:\n        table: A Table subclass to query\n        **kwargs: Column-value pairs to filter by\n\n    Returns:\n        A Table instance corresponding to the matched row\n\n    Raises:\n        Exception: If no row matches the criteria\n\n    Example:\n        ```python\n        # Get user by ID\n        user = db.get(User, id=1)\n\n        # Get user by name\n        user = db.get(User, name=\"John Doe\")\n        ```\n    \"\"\"\n    sql, fields, params = table._get_select_where_sql(**kwargs)\n    row = self.connection.execute(sql, params).fetchone()\n\n    if row is None:\n        raise Exception(f\"{table.__name__} instance with {kwargs} does not exist\")\n\n    properties = {}\n\n    for field, value in zip(fields, row):\n        if field.endswith(\"_id\"):\n            foreign_key = field[:-3]\n            foreign_table = getattr(table, foreign_key).table\n            properties[foreign_key] = self.get(foreign_table, id=value)\n        else:\n            properties[field] = value\n\n    return table(**properties)\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Database.save","title":"<code>save(instance)</code>","text":"<p>Save a Table instance to the database.</p> <p>This method inserts a new row into the corresponding database table. It automatically sets the instance's id attribute to the new row's ID.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Table</code> <p>A Table instance to save</p> required Example <pre><code>user = User(name=\"John Doe\", age=30)\ndb.save(user)  # user.id is now set to the new row's ID\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>def save(self, instance: \"Table\"):\n    \"\"\"\n    Save a Table instance to the database.\n\n    This method inserts a new row into the corresponding database table.\n    It automatically sets the instance's id attribute to the new row's ID.\n\n    Args:\n        instance: A Table instance to save\n\n    Example:\n        ```python\n        user = User(name=\"John Doe\", age=30)\n        db.save(user)  # user.id is now set to the new row's ID\n        ```\n    \"\"\"\n    sql, values = instance._get_insert_sql()\n    cursor = self.connection.execute(sql, values)\n    instance._data[\"id\"] = cursor.lastrowid\n    self.connection.commit()\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Database.update","title":"<code>update(instance)</code>","text":"<p>Update an existing row in the database.</p> <p>This method updates the row corresponding to the given instance with the current values of the instance's attributes.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Table</code> <p>A Table instance to update. Must have an id attribute.</p> required Example <pre><code>user = db.get(User, id=1)\nuser.name = \"Jane Doe\"\ndb.update(user)\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>def update(self, instance: \"Table\"):\n    \"\"\"\n    Update an existing row in the database.\n\n    This method updates the row corresponding to the given instance with the\n    current values of the instance's attributes.\n\n    Args:\n        instance: A Table instance to update. Must have an id attribute.\n\n    Example:\n        ```python\n        user = db.get(User, id=1)\n        user.name = \"Jane Doe\"\n        db.update(user)\n        ```\n    \"\"\"\n    sql, values = instance._get_update_sql()\n    self.connection.execute(sql, values)\n    self.connection.commit()\n</code></pre>"},{"location":"api/orm/#table-class","title":"Table Class","text":""},{"location":"api/orm/#plinx.orm.orm.Table","title":"<code>plinx.orm.orm.Table</code>","text":"<p>Base class for ORM models in Plinx.</p> <p>This class is used as a base class for defining database tables. Subclasses should define class attributes using Column and ForeignKey to describe the table schema.</p> <p>The Table class provides methods for generating SQL statements for CRUD operations, which are used by the Database class.</p> <p>Examples:</p> <pre><code>class User(Table):\n    name = Column(str)\n    age = Column(int)\n\nclass Post(Table):\n    title = Column(str)\n    content = Column(str)\n    author = ForeignKey(User)\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>class Table:\n    \"\"\"\n    Base class for ORM models in Plinx.\n\n    This class is used as a base class for defining database tables.\n    Subclasses should define class attributes using Column and ForeignKey\n    to describe the table schema.\n\n    The Table class provides methods for generating SQL statements for\n    CRUD operations, which are used by the Database class.\n\n    Examples:\n        ```python\n        class User(Table):\n            name = Column(str)\n            age = Column(int)\n\n        class Post(Table):\n            title = Column(str)\n            content = Column(str)\n            author = ForeignKey(User)\n        ```\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initialize a new record.\n\n        Args:\n            **kwargs: Column values to initialize with\n        \"\"\"\n        self._data = {\"id\": None}\n\n        for key, value in kwargs.items():\n            self._data[key] = value\n\n    def __getattribute__(self, key):\n        \"\"\"\n        Custom attribute access for Table instances.\n\n        This method allows Table instances to access column values as attributes,\n        rather than accessing self._data directly.\n\n        Args:\n            key: Attribute name to access\n\n        Returns:\n            The attribute value\n        \"\"\"\n        # Why use super().__getattribute__ instead of self._data[key]?\n        # Because otherwise it will create an infinite loop since __getattribute__ will call itself\n        # and will never return the value\n        _data = super().__getattribute__(\"_data\")\n        if key in _data:\n            return _data[key]\n        return super().__getattribute__(key)\n\n    def __setattr__(self, key, value):\n        \"\"\"\n        Custom attribute assignment for Table instances.\n\n        This method ensures that when setting an attribute that corresponds to\n        a column, the value is stored in self._data.\n\n        Args:\n            key: Attribute name to set\n            value: Value to assign\n        \"\"\"\n        super().__setattr__(key, value)\n        if key in self._data:\n            self._data[key] = value\n\n    @classmethod\n    def _get_create_sql(cls):\n        \"\"\"\n        Generate SQL for creating the table.\n\n        Returns:\n            SQL string for creating the table\n        \"\"\"\n        CREATE_TABLE_SQL = \"CREATE TABLE IF NOT EXISTS {name} ({fields});\"\n        fields = [\n            \"id INTEGER PRIMARY KEY AUTOINCREMENT\",\n        ]\n\n        for name, field in inspect.getmembers(cls):\n            if isinstance(field, Column):\n                fields.append(f\"{name} {field.sql_type}\")\n            elif isinstance(field, ForeignKey):\n                fields.append(f\"{name}_id INTEGER\")\n\n        fields = \", \".join(fields)\n        name = cls.__name__.lower()\n        return CREATE_TABLE_SQL.format(name=name, fields=fields)\n\n    def _get_insert_sql(self):\n        \"\"\"\n        Generate SQL for inserting a record.\n\n        Returns:\n            Tuple of (SQL string, parameter values list)\n        \"\"\"\n        INSERT_SQL = \"INSERT INTO {name} ({fields}) VALUES ({placeholders});\"\n\n        cls = self.__class__\n        fields = []\n        placeholders = []\n        values = []\n\n        for name, field in inspect.getmembers(cls):\n            if isinstance(field, Column):\n                fields.append(name)\n                values.append(getattr(self, name))\n                placeholders.append(\"?\")\n            elif isinstance(field, ForeignKey):\n                fields.append(name + \"_id\")\n                values.append(getattr(self, name).id)\n                placeholders.append(\"?\")\n\n        fields = \", \".join(fields)\n        placeholders = \", \".join(placeholders)\n\n        sql = INSERT_SQL.format(\n            name=cls.__name__.lower(), fields=fields, placeholders=placeholders\n        )\n\n        return sql, values\n\n    @classmethod\n    def _get_select_all_sql(cls):\n        \"\"\"\n        Generate SQL for selecting all records.\n\n        Returns:\n            Tuple of (SQL string, field names list)\n        \"\"\"\n        SELECT_ALL_SQL = \"SELECT {fields} FROM {name};\"\n\n        fields = [\"id\"]\n\n        for name, field in inspect.getmembers(cls):\n            if isinstance(field, Column):\n                fields.append(name)\n            elif isinstance(field, ForeignKey):\n                fields.append(name + \"_id\")\n\n        return (\n            SELECT_ALL_SQL.format(\n                fields=\", \".join(fields),\n                name=cls.__name__.lower(),\n            ),\n            fields,\n        )\n\n    @classmethod\n    def _get_select_where_sql(cls, **kwargs):\n        \"\"\"\n        Generate SQL for selecting records by criteria.\n\n        Args:\n            **kwargs: Column-value pairs to filter by\n\n        Returns:\n            Tuple of (SQL string, field names list, parameter values list)\n        \"\"\"\n        SELECT_WHERE_SQL = \"SELECT {fields} FROM {name} WHERE {query};\"\n\n        fields = [\"id\"]\n        query = []\n        values = []\n\n        for name, field in inspect.getmembers(cls):\n            if isinstance(field, Column):\n                fields.append(name)\n            elif isinstance(field, ForeignKey):\n                fields.append(name + \"_id\")\n\n        for key, value in kwargs.items():\n            query.append(f\"{key} = ?\")\n            values.append(value)\n\n        return (\n            SELECT_WHERE_SQL.format(\n                fields=\", \".join(fields),\n                name=cls.__name__.lower(),\n                query=\", \".join(query),\n            ),\n            fields,\n            values,\n        )\n\n    def _get_update_sql(self):\n        \"\"\"\n        Generate SQL for updating a record.\n\n        Returns:\n            Tuple of (SQL string, parameter values list)\n        \"\"\"\n        UPDATE_SQL = \"UPDATE {name} SET {fields} WHERE id = ?;\"\n\n        cls = self.__class__\n        fields = []\n        values = []\n\n        for name, field in inspect.getmembers(cls):\n            if isinstance(field, Column):\n                fields.append(name)\n                values.append(getattr(self, name))\n            elif isinstance(field, ForeignKey):\n                fields.append(name + \"_id\")\n                values.append(getattr(self, name).id)\n\n        values.append(getattr(self, \"id\"))\n\n        return (\n            UPDATE_SQL.format(\n                name=cls.__name__.lower(),\n                fields=\", \".join([f\"{field} = ?\" for field in fields]),\n            ),\n            values,\n        )\n\n    def _get_delete_sql(self):\n        \"\"\"\n        Generate SQL for deleting a record.\n\n        Returns:\n            Tuple of (SQL string, parameter values list)\n        \"\"\"\n        DELETE_SQL = \"DELETE FROM {name} WHERE id = ?;\"\n\n        return DELETE_SQL.format(name=self.__class__.__name__.lower()), [\n            getattr(self, \"id\")\n        ]\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Table-functions","title":"Functions","text":""},{"location":"api/orm/#plinx.orm.orm.Table.__getattribute__","title":"<code>__getattribute__(key)</code>","text":"<p>Custom attribute access for Table instances.</p> <p>This method allows Table instances to access column values as attributes, rather than accessing self._data directly.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>Attribute name to access</p> required <p>Returns:</p> Type Description <p>The attribute value</p> Source code in <code>plinx/orm/orm.py</code> <pre><code>def __getattribute__(self, key):\n    \"\"\"\n    Custom attribute access for Table instances.\n\n    This method allows Table instances to access column values as attributes,\n    rather than accessing self._data directly.\n\n    Args:\n        key: Attribute name to access\n\n    Returns:\n        The attribute value\n    \"\"\"\n    # Why use super().__getattribute__ instead of self._data[key]?\n    # Because otherwise it will create an infinite loop since __getattribute__ will call itself\n    # and will never return the value\n    _data = super().__getattribute__(\"_data\")\n    if key in _data:\n        return _data[key]\n    return super().__getattribute__(key)\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Table.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize a new record.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Column values to initialize with</p> <code>{}</code> Source code in <code>plinx/orm/orm.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    Initialize a new record.\n\n    Args:\n        **kwargs: Column values to initialize with\n    \"\"\"\n    self._data = {\"id\": None}\n\n    for key, value in kwargs.items():\n        self._data[key] = value\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Table.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"<p>Custom attribute assignment for Table instances.</p> <p>This method ensures that when setting an attribute that corresponds to a column, the value is stored in self._data.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>Attribute name to set</p> required <code>value</code> <p>Value to assign</p> required Source code in <code>plinx/orm/orm.py</code> <pre><code>def __setattr__(self, key, value):\n    \"\"\"\n    Custom attribute assignment for Table instances.\n\n    This method ensures that when setting an attribute that corresponds to\n    a column, the value is stored in self._data.\n\n    Args:\n        key: Attribute name to set\n        value: Value to assign\n    \"\"\"\n    super().__setattr__(key, value)\n    if key in self._data:\n        self._data[key] = value\n</code></pre>"},{"location":"api/orm/#column-class","title":"Column Class","text":""},{"location":"api/orm/#plinx.orm.orm.Column","title":"<code>plinx.orm.orm.Column</code>","text":"<p>Define a column in a database table.</p> <p>This class represents a column definition for a Table class. It stores the column's type and can generate the corresponding SQL type.</p> <p>Examples:</p> <pre><code>class User(Table):\n    name = Column(str)  # TEXT column\n    age = Column(int)   # INTEGER column\n    active = Column(bool)  # INTEGER column (0=False, 1=True)\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>class Column:\n    \"\"\"\n    Define a column in a database table.\n\n    This class represents a column definition for a Table class. It stores\n    the column's type and can generate the corresponding SQL type.\n\n    Examples:\n        ```python\n        class User(Table):\n            name = Column(str)  # TEXT column\n            age = Column(int)   # INTEGER column\n            active = Column(bool)  # INTEGER column (0=False, 1=True)\n        ```\n    \"\"\"\n\n    def __init__(self, type: Generic[T]):\n        \"\"\"\n        Initialize a new column.\n\n        Args:\n            type: Python type for the column (str, int, float, bool, bytes)\n        \"\"\"\n        self.type = type\n\n    @property\n    def sql_type(self):\n        \"\"\"\n        Get the SQL type corresponding to this column's Python type.\n\n        Returns:\n            SQL type string (e.g., \"TEXT\", \"INTEGER\", \"REAL\")\n        \"\"\"\n        return SQLITE_TYPE_MAP[self.type]\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.Column-attributes","title":"Attributes","text":""},{"location":"api/orm/#plinx.orm.orm.Column.sql_type","title":"<code>sql_type</code>  <code>property</code>","text":"<p>Get the SQL type corresponding to this column's Python type.</p> <p>Returns:</p> Type Description <p>SQL type string (e.g., \"TEXT\", \"INTEGER\", \"REAL\")</p>"},{"location":"api/orm/#plinx.orm.orm.Column-functions","title":"Functions","text":""},{"location":"api/orm/#plinx.orm.orm.Column.__init__","title":"<code>__init__(type)</code>","text":"<p>Initialize a new column.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Generic[T]</code> <p>Python type for the column (str, int, float, bool, bytes)</p> required Source code in <code>plinx/orm/orm.py</code> <pre><code>def __init__(self, type: Generic[T]):\n    \"\"\"\n    Initialize a new column.\n\n    Args:\n        type: Python type for the column (str, int, float, bool, bytes)\n    \"\"\"\n    self.type = type\n</code></pre>"},{"location":"api/orm/#foreignkey-class","title":"ForeignKey Class","text":""},{"location":"api/orm/#plinx.orm.orm.ForeignKey","title":"<code>plinx.orm.orm.ForeignKey</code>","text":"<p>Define a foreign key relationship between tables.</p> <p>This class represents a foreign key constraint in a database schema, linking one Table class to another.</p> <p>Examples:</p> <pre><code>class Author(Table):\n    name = Column(str)\n\nclass Book(Table):\n    title = Column(str)\n    author = ForeignKey(Author)  # Creates author_id column\n</code></pre> Source code in <code>plinx/orm/orm.py</code> <pre><code>class ForeignKey:\n    \"\"\"\n    Define a foreign key relationship between tables.\n\n    This class represents a foreign key constraint in a database schema,\n    linking one Table class to another.\n\n    Examples:\n        ```python\n        class Author(Table):\n            name = Column(str)\n\n        class Book(Table):\n            title = Column(str)\n            author = ForeignKey(Author)  # Creates author_id column\n        ```\n    \"\"\"\n\n    def __init__(self, table):\n        \"\"\"\n        Initialize a new foreign key.\n\n        Args:\n            table: The Table subclass that this foreign key references\n        \"\"\"\n        self.table = table\n</code></pre>"},{"location":"api/orm/#plinx.orm.orm.ForeignKey-functions","title":"Functions","text":""},{"location":"api/orm/#plinx.orm.orm.ForeignKey.__init__","title":"<code>__init__(table)</code>","text":"<p>Initialize a new foreign key.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <p>The Table subclass that this foreign key references</p> required Source code in <code>plinx/orm/orm.py</code> <pre><code>def __init__(self, table):\n    \"\"\"\n    Initialize a new foreign key.\n\n    Args:\n        table: The Table subclass that this foreign key references\n    \"\"\"\n    self.table = table\n</code></pre>"},{"location":"api/orm/#type-mapping","title":"Type Mapping","text":"<p>The ORM maps Python types to SQLite types according to the following table:</p> Python Type SQLite Type <code>str</code> TEXT <code>int</code> INTEGER <code>float</code> REAL <code>bool</code> INTEGER <code>bytes</code> BLOB"},{"location":"api/orm/#examples","title":"Examples","text":""},{"location":"api/orm/#basic-orm-usage","title":"Basic ORM Usage","text":"<pre><code>from plinx.orm import Database, Table, Column, ForeignKey\n\n# Connect to database\ndb = Database(\"example.db\")\n\n# Define tables\nclass User(Table):\n    name = Column(str)\n    age = Column(int)\n\nclass Post(Table):\n    title = Column(str)\n    content = Column(str)\n    author = ForeignKey(User)\n\n# Create tables\ndb.create(User)\ndb.create(Post)\n\n# Create records\nuser = User(name=\"John Doe\", age=30)\ndb.save(user)\n\npost = Post(title=\"Hello World\", content=\"This is my first post\", author=user)\ndb.save(post)\n\n# Query records\nall_users = db.all(User)\nfor user in all_users:\n    print(f\"User: {user.name}, Age: {user.age}\")\n\n# Get a specific record\npost = db.get(Post, id=1)\nprint(f\"Post: {post.title} by {post.author.name}\")\n\n# Update a record\npost.content = \"Updated content\"\ndb.update(post)\n\n# Delete a record\ndb.delete(post)\n\n# Close connection when done\ndb.close()\n</code></pre>"},{"location":"api/orm/#advanced-querying","title":"Advanced Querying","text":"<pre><code># Get by non-primary key field\ntry:\n    user = db.get(User, name=\"John Doe\")\n    print(f\"Found user: {user.name}\")\nexcept Exception as e:\n    print(f\"User not found: {e}\")\n</code></pre>"},{"location":"api/orm/#table-introspection","title":"Table Introspection","text":"<pre><code># List all tables in the database\ntables = db.tables\nprint(f\"Tables in database: {tables}\")\n</code></pre>"},{"location":"api/orm/#custom-table-methods","title":"Custom Table Methods","text":"<p>You can add custom methods to your table classes to encapsulate business logic:</p> <pre><code>class User(Table):\n    name = Column(str)\n    email = Column(str)\n    age = Column(int)\n\n    def is_adult(self):\n        return self.age &gt;= 18\n\n    def get_email_domain(self):\n        return self.email.split('@')[1] if '@' in self.email else None\n\n# Usage\nuser = db.get(User, id=1)\nif user.is_adult():\n    print(f\"{user.name} is an adult\")\n</code></pre>"},{"location":"api/orm/#working-with-relationships","title":"Working with Relationships","text":"<pre><code>class Department(Table):\n    name = Column(str)\n\nclass Employee(Table):\n    name = Column(str)\n    department = ForeignKey(Department)\n    salary = Column(float)\n\n# Create tables\ndb.create(Department)\ndb.create(Employee)\n\n# Create related records\nengineering = Department(name=\"Engineering\")\ndb.save(engineering)\n\nalice = Employee(name=\"Alice\", department=engineering, salary=75000.0)\nbob = Employee(name=\"Bob\", department=engineering, salary=85000.0)\ndb.save(alice)\ndb.save(bob)\n\n# Query with relationship\nemployee = db.get(Employee, name=\"Alice\")\nprint(f\"{employee.name} works in {employee.department.name}\")\n</code></pre>"},{"location":"api/orm/#limitations","title":"Limitations","text":"<p>The current version of the Plinx ORM has the following limitations:</p> <ol> <li>SQLite Only: Only supports SQLite databases</li> <li>Basic Querying: No complex filtering, ordering, or joins in queries</li> <li>No Migrations: No built-in support for schema migrations</li> <li>Eager Loading: All relationships are eagerly loaded (no lazy loading)</li> <li>Simple Relationships: Only supports one-to-many relationships via ForeignKey</li> </ol> <p>These limitations are intentional to keep the ORM simple and focused while still being useful for many common scenarios.</p>"},{"location":"api/response/","title":"Response API","text":"<p>The <code>response</code> module provides the <code>PlinxResponse</code> class, which handles HTTP response generation in Plinx applications. This class offers a simple interface for setting response content, status codes, and headers.</p>"},{"location":"api/response/#plinxresponse-class","title":"PlinxResponse Class","text":""},{"location":"api/response/#plinx.response.PlinxResponse","title":"<code>plinx.response.PlinxResponse</code>","text":"<p>Response class for the Plinx web framework.</p> <p>This class provides a simple interface for constructing HTTP responses, with high-level helpers for common response types like JSON and plain text. It wraps WebOb's Response for actual WSGI compliance and output generation.</p> <p>The class provides multiple ways to set response content:</p> <ol> <li>Set the <code>text</code> attribute for plain text responses</li> <li>Set the <code>json</code> attribute for JSON responses</li> <li>Set the <code>body</code> attribute directly for binary data</li> </ol> <p>It also allows setting status codes, content types, and custom headers.</p> <p>Examples:</p> <p>Plain text response: <pre><code>def handler(request, response):\n    response.text = \"Hello, World!\"\n    response.status_code = 200  # Optional, defaults to 200\n</code></pre></p> <p>JSON response: <pre><code>def handler(request, response):\n    response.json = {\"message\": \"Hello, World!\"}\n    # Content-Type will automatically be set to application/json\n</code></pre></p> <p>Custom headers: <pre><code>def handler(request, response):\n    response.text = \"Not Found\"\n    response.status_code = 404\n    response.headers[\"X-Custom-Header\"] = \"Value\"\n</code></pre></p> Source code in <code>plinx/response.py</code> <pre><code>class PlinxResponse:\n    \"\"\"\n    Response class for the Plinx web framework.\n\n    This class provides a simple interface for constructing HTTP responses,\n    with high-level helpers for common response types like JSON and plain text.\n    It wraps WebOb's Response for actual WSGI compliance and output generation.\n\n    The class provides multiple ways to set response content:\n\n    1. Set the `text` attribute for plain text responses\n    2. Set the `json` attribute for JSON responses\n    3. Set the `body` attribute directly for binary data\n\n    It also allows setting status codes, content types, and custom headers.\n\n    Examples:\n        Plain text response:\n        ```python\n        def handler(request, response):\n            response.text = \"Hello, World!\"\n            response.status_code = 200  # Optional, defaults to 200\n        ```\n\n        JSON response:\n        ```python\n        def handler(request, response):\n            response.json = {\"message\": \"Hello, World!\"}\n            # Content-Type will automatically be set to application/json\n        ```\n\n        Custom headers:\n        ```python\n        def handler(request, response):\n            response.text = \"Not Found\"\n            response.status_code = 404\n            response.headers[\"X-Custom-Header\"] = \"Value\"\n        ```\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a new response object.\n\n        Sets up default values for the response attributes:\n        - json: None (will be serialized to JSON if set)\n        - text: None (will be encoded to UTF-8 if set)\n        - content_type: None (will be set based on response type)\n        - body: Empty bytes (raw response body)\n        - status_code: 200 (OK)\n        - headers: Empty dict (custom HTTP headers)\n        \"\"\"\n        self.json = None\n        self.text = None\n        self.content_type = None\n        self.body = b\"\"\n        self.status_code = 200\n        self.headers = {}\n\n    def __call__(\n        self,\n        environ: WSGIEnvironment,\n        start_response: StartResponse,\n    ) -&gt; Iterable[bytes]:\n        \"\"\"\n        WSGI callable interface for the response.\n\n        This makes the response object act as a WSGI application,\n        which is required for compatibility with WSGI servers.\n        It delegates the actual WSGI handling to WebOb's Response.\n\n        Args:\n            environ: The WSGI environment dictionary\n            start_response: The WSGI start_response callable\n\n        Returns:\n            An iterable of bytes representing the response body\n        \"\"\"\n\n        self.set_body_and_content_type()\n\n        response = WebObResponse(\n            body=self.body,\n            content_type=self.content_type,\n            status=self.status_code,\n            headers=self.headers,\n        )\n        return response(environ, start_response)\n\n    def set_body_and_content_type(self):\n        \"\"\"\n        Prepare the response body and content type based on the response attributes.\n\n        This method is called automatically before the response is returned.\n        It handles the conversion of high-level response attributes (`json`, `text`)\n        into the raw response body and appropriate content type.\n\n        The priority order is:\n        1. If `json` is set, encode it as JSON and set content_type to application/json\n        2. If `text` is set, encode it as UTF-8 and set content_type to text/plain\n        3. Otherwise, use the existing `body` and `content_type`\n        \"\"\"\n        if self.json is not None:\n            self.body = json.dumps(self.json).encode(\"UTF-8\")\n            self.content_type = \"application/json\"\n        elif self.text is not None:\n            self.body = (\n                self.text.encode(\"utf-8\") if isinstance(self.text, str) else self.text\n            )\n            self.content_type = \"text/plain\"\n\n        if self.content_type is not None:\n            self.headers[\"Content-Type\"] = self.content_type\n</code></pre>"},{"location":"api/response/#plinx.response.PlinxResponse-functions","title":"Functions","text":""},{"location":"api/response/#plinx.response.PlinxResponse.__call__","title":"<code>__call__(environ, start_response)</code>","text":"<p>WSGI callable interface for the response.</p> <p>This makes the response object act as a WSGI application, which is required for compatibility with WSGI servers. It delegates the actual WSGI handling to WebOb's Response.</p> <p>Parameters:</p> Name Type Description Default <code>environ</code> <code>WSGIEnvironment</code> <p>The WSGI environment dictionary</p> required <code>start_response</code> <code>StartResponse</code> <p>The WSGI start_response callable</p> required <p>Returns:</p> Type Description <code>Iterable[bytes]</code> <p>An iterable of bytes representing the response body</p> Source code in <code>plinx/response.py</code> <pre><code>def __call__(\n    self,\n    environ: WSGIEnvironment,\n    start_response: StartResponse,\n) -&gt; Iterable[bytes]:\n    \"\"\"\n    WSGI callable interface for the response.\n\n    This makes the response object act as a WSGI application,\n    which is required for compatibility with WSGI servers.\n    It delegates the actual WSGI handling to WebOb's Response.\n\n    Args:\n        environ: The WSGI environment dictionary\n        start_response: The WSGI start_response callable\n\n    Returns:\n        An iterable of bytes representing the response body\n    \"\"\"\n\n    self.set_body_and_content_type()\n\n    response = WebObResponse(\n        body=self.body,\n        content_type=self.content_type,\n        status=self.status_code,\n        headers=self.headers,\n    )\n    return response(environ, start_response)\n</code></pre>"},{"location":"api/response/#plinx.response.PlinxResponse.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new response object.</p> <p>Sets up default values for the response attributes: - json: None (will be serialized to JSON if set) - text: None (will be encoded to UTF-8 if set) - content_type: None (will be set based on response type) - body: Empty bytes (raw response body) - status_code: 200 (OK) - headers: Empty dict (custom HTTP headers)</p> Source code in <code>plinx/response.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize a new response object.\n\n    Sets up default values for the response attributes:\n    - json: None (will be serialized to JSON if set)\n    - text: None (will be encoded to UTF-8 if set)\n    - content_type: None (will be set based on response type)\n    - body: Empty bytes (raw response body)\n    - status_code: 200 (OK)\n    - headers: Empty dict (custom HTTP headers)\n    \"\"\"\n    self.json = None\n    self.text = None\n    self.content_type = None\n    self.body = b\"\"\n    self.status_code = 200\n    self.headers = {}\n</code></pre>"},{"location":"api/response/#plinx.response.PlinxResponse.set_body_and_content_type","title":"<code>set_body_and_content_type()</code>","text":"<p>Prepare the response body and content type based on the response attributes.</p> <p>This method is called automatically before the response is returned. It handles the conversion of high-level response attributes (<code>json</code>, <code>text</code>) into the raw response body and appropriate content type.</p> <p>The priority order is: 1. If <code>json</code> is set, encode it as JSON and set content_type to application/json 2. If <code>text</code> is set, encode it as UTF-8 and set content_type to text/plain 3. Otherwise, use the existing <code>body</code> and <code>content_type</code></p> Source code in <code>plinx/response.py</code> <pre><code>def set_body_and_content_type(self):\n    \"\"\"\n    Prepare the response body and content type based on the response attributes.\n\n    This method is called automatically before the response is returned.\n    It handles the conversion of high-level response attributes (`json`, `text`)\n    into the raw response body and appropriate content type.\n\n    The priority order is:\n    1. If `json` is set, encode it as JSON and set content_type to application/json\n    2. If `text` is set, encode it as UTF-8 and set content_type to text/plain\n    3. Otherwise, use the existing `body` and `content_type`\n    \"\"\"\n    if self.json is not None:\n        self.body = json.dumps(self.json).encode(\"UTF-8\")\n        self.content_type = \"application/json\"\n    elif self.text is not None:\n        self.body = (\n            self.text.encode(\"utf-8\") if isinstance(self.text, str) else self.text\n        )\n        self.content_type = \"text/plain\"\n\n    if self.content_type is not None:\n        self.headers[\"Content-Type\"] = self.content_type\n</code></pre>"},{"location":"api/response/#examples","title":"Examples","text":""},{"location":"api/response/#text-responses","title":"Text Responses","text":"<pre><code>@app.route(\"/hello\")\ndef hello(request, response):\n    response.text = \"Hello, World!\"\n    response.status_code = 200  # Optional, defaults to 200\n</code></pre>"},{"location":"api/response/#json-responses","title":"JSON Responses","text":"<pre><code>@app.route(\"/api/data\")\ndef get_data(request, response):\n    response.json = {\n        \"name\": \"Plinx\",\n        \"version\": \"1.0.0\",\n        \"features\": [\"routing\", \"middleware\", \"orm\"]\n    }\n    # Content-Type is automatically set to application/json\n</code></pre>"},{"location":"api/response/#custom-status-codes","title":"Custom Status Codes","text":"<pre><code>from plinx.status_codes import StatusCodes\n\n@app.route(\"/not-found\")\ndef not_found(request, response):\n    response.text = \"Resource not found\"\n    response.status_code = StatusCodes.NOT_FOUND.value  # 404\n</code></pre>"},{"location":"api/response/#setting-headers","title":"Setting Headers","text":"<pre><code>@app.route(\"/download\")\ndef download(request, response):\n    response.text = \"File content goes here\"\n    response.headers[\"Content-Type\"] = \"text/plain\"\n    response.headers[\"Content-Disposition\"] = \"attachment; filename=sample.txt\"\n</code></pre>"},{"location":"api/response/#binary-responses","title":"Binary Responses","text":"<pre><code>@app.route(\"/image\")\ndef get_image(request, response):\n    with open(\"image.png\", \"rb\") as f:\n        response.body = f.read()\n    response.content_type = \"image/png\"\n</code></pre>"},{"location":"api/response/#response-properties","title":"Response Properties","text":"Property Type Description <code>text</code> <code>str</code> Text content of the response (sets content type to \"text/plain\") <code>json</code> <code>Any</code> JSON-serializable content (sets content type to \"application/json\") <code>body</code> <code>bytes</code> Raw response body as bytes <code>content_type</code> <code>str</code> MIME type of the response (e.g., \"text/html\", \"application/json\") <code>status_code</code> <code>int</code> HTTP status code (default: 200) <code>headers</code> <code>dict</code> Dictionary of HTTP headers"},{"location":"api/response/#content-type-handling","title":"Content Type Handling","text":"<p>The <code>PlinxResponse</code> class automatically sets the Content-Type header based on how you set the response content:</p> <ol> <li>If you set <code>response.json</code>, the content type is set to \"application/json\"</li> <li>If you set <code>response.text</code>, the content type is set to \"text/plain\"</li> <li>If you set <code>response.body</code> directly, you should also set <code>response.content_type</code> manually</li> </ol>"},{"location":"api/response/#internal-workflow","title":"Internal Workflow","text":"<p>When a response is being prepared to be sent back to the client:</p> <ol> <li>The <code>set_body_and_content_type()</code> method is called to ensure the response body and headers are properly prepared</li> <li>The response is converted to a WebOb Response object</li> <li>The WebOb Response handles the actual WSGI response generation</li> </ol>"},{"location":"api/response/#custom-response-classes","title":"Custom Response Classes","text":"<p>If you need to extend the <code>PlinxResponse</code> class with additional functionality, you can create a subclass:</p> <pre><code>from plinx.response import PlinxResponse\n\nclass HTMLResponse(PlinxResponse):\n    def set_html(self, html_content):\n        self.body = html_content.encode(\"utf-8\")\n        self.content_type = \"text/html\"\n\n    def render_template(self, template_name, **context):\n        # Simple template rendering example\n        with open(f\"templates/{template_name}.html\") as f:\n            template = f.read()\n\n        # Very basic template substitution\n        for key, value in context.items():\n            template = template.replace(f\"{{{{{key}}}}}\", str(value))\n\n        self.set_html(template)\n</code></pre> <p>To use your custom response class, you would need to modify your application to create instances of your class instead of the standard <code>PlinxResponse</code>.</p>"},{"location":"development/contributing/","title":"Contributing to Plinx","text":"<p>Thank you for considering contributing to Plinx! This document provides guidelines and information to make the contribution process smooth and effective.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#fork-and-clone","title":"Fork and Clone","text":"<p>First, fork the repository on GitHub, then clone your fork locally:</p> <pre><code>git clone https://github.com/your-username/Plinx.git\ncd Plinx\n</code></pre>"},{"location":"development/contributing/#set-up-development-environment","title":"Set Up Development Environment","text":"<p>We recommend using a virtual environment:</p> <pre><code># Using venv\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e .\n\n# Install dev dependencies\npip install pytest pytest-cov flake8 black twine mkdocs mkdocs-material mkdocstrings mkdocstrings-python\n</code></pre>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#branch-naming","title":"Branch Naming","text":"<p>Use descriptive branch names that reflect the changes you're making:</p> <ul> <li><code>feature/description</code> for new features</li> <li><code>bugfix/description</code> for bug fixes</li> <li><code>docs/description</code> for documentation changes</li> <li><code>refactor/description</code> for code refactoring</li> </ul>"},{"location":"development/contributing/#coding-standards","title":"Coding Standards","text":"<p>We follow standard Python conventions:</p> <ul> <li>Use PEP 8 style guidelines</li> <li>Add docstrings following the Google style</li> <li>Include type hints where appropriate</li> <li>Keep functions focused and relatively short</li> </ul> <p>You can check your code with flake8:</p> <pre><code>flake8 plinx tests\n</code></pre> <p>And format it with black:</p> <pre><code>black plinx tests\n</code></pre>"},{"location":"development/contributing/#writing-tests","title":"Writing Tests","text":"<p>All new features should include tests. We use pytest for testing:</p> <pre><code># Run all tests\npytest\n\n# Run with coverage report\npytest --cov=plinx\n\n# Run specific test file\npytest tests/test_specific.py\n</code></pre>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update your fork to the latest main branch</li> <li>Create a new branch for your changes</li> <li>Make your changes and write tests</li> <li>Run the test suite to ensure everything passes</li> <li>Update documentation if necessary</li> <li>Submit a pull request with a clear description of the changes</li> </ol>"},{"location":"development/contributing/#pr-description-template","title":"PR Description Template","text":"<pre><code>## Description\n[Describe the changes you've made]\n\n## Related Issue\n[Link to any related issues]\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Code refactoring\n- [ ] Other (please describe)\n\n## How Has This Been Tested?\n[Describe the tests you ran]\n\n## Checklist\n- [ ] My code follows the style guidelines\n- [ ] I have added tests that prove my fix/feature works\n- [ ] All tests pass locally\n- [ ] I have updated the documentation accordingly\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":""},{"location":"development/contributing/#updating-documentation","title":"Updating Documentation","text":"<p>If your changes affect user-facing functionality, update the documentation:</p> <ol> <li>Update in-code docstrings</li> <li>Update or add Markdown files in the <code>docs/</code> directory if needed</li> <li>Build and check the documentation locally:</li> </ol> <pre><code>mkdocs serve\n# View at http://localhost:8000\n</code></pre>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>The release process is handled by maintainers, but here's the general workflow:</p> <ol> <li>Update version in <code>VERSION</code> file</li> <li>Update documentation if needed</li> <li>Create a new GitHub release with release notes</li> <li>Build and publish to PyPI</li> </ol>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"development/contributing/#our-pledge","title":"Our Pledge","text":"<p>We are committed to providing a friendly, safe, and welcoming environment for all contributors.</p>"},{"location":"development/contributing/#our-standards","title":"Our Standards","text":"<ul> <li>Be respectful and inclusive</li> <li>Accept constructive criticism gracefully</li> <li>Focus on what's best for the community</li> <li>Show empathy towards other community members</li> </ul>"},{"location":"development/contributing/#enforcement","title":"Enforcement","text":"<p>Violations of our code of conduct may result in temporary or permanent exclusion from project participation. Incidents can be reported to the project maintainers.</p>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<p>If you need help with contributing, you can:</p> <ul> <li>Open an issue with questions</li> <li>Reach out to maintainers directly</li> <li>Check the documentation</li> </ul> <p>Thank you for contributing to Plinx! Your time and expertise help make this project better for everyone.</p>"},{"location":"development/design-philosophy/","title":"Design Philosophy","text":"<p>This page outlines the core design principles that guided the development of Plinx 1.0.0. Understanding these principles provides insight into why certain design choices were made.</p>"},{"location":"development/design-philosophy/#core-principles","title":"Core Principles","text":""},{"location":"development/design-philosophy/#1-simplicity-over-complexity","title":"1. Simplicity Over Complexity","text":"<p>Plinx prioritizes simplicity in its API and implementation. We believe that a framework should be easy to understand, both for users and for developers who want to learn from the code. This means:</p> <ul> <li>Favoring explicit code over \"magic\" behaviors</li> <li>Keeping the API surface area small and focused</li> <li>Minimizing indirection and abstraction layers</li> <li>Making the common case easy and the complex case possible</li> </ul> <p>Simplicity doesn't mean lack of power\u2014it means thoughtfully designing interfaces that expose the right level of abstraction for the task at hand.</p>"},{"location":"development/design-philosophy/#2-educational-value","title":"2. Educational Value","text":"<p>Plinx was designed partly as an educational tool. The codebase should be readable and approachable enough that someone can learn web framework design by studying it. This influenced decisions like:</p> <ul> <li>Clear, well-documented code with minimal \"cleverness\"</li> <li>Straightforward implementations that prioritize readability</li> <li>Thorough docstrings explaining not just what code does, but why</li> <li>A codebase small enough to be understood as a whole</li> </ul> <p>We want Plinx to be a framework that helps developers understand how web frameworks and ORMs work under the hood.</p>"},{"location":"development/design-philosophy/#3-minimal-dependencies","title":"3. Minimal Dependencies","text":"<p>Plinx aims to have as few external dependencies as possible. This makes the framework:</p> <ul> <li>Easier to install and deploy</li> <li>More stable across environments</li> <li>Less susceptible to security issues in dependencies</li> <li>More maintainable over time</li> </ul> <p>The core dependencies (WebOb, parse) were chosen carefully for their stability, simplicity, and focused purpose.</p>"},{"location":"development/design-philosophy/#4-pythonic-design","title":"4. Pythonic Design","text":"<p>The framework embraces Python's strengths and conventions:</p> <ul> <li>Using decorators for route registration (<code>@app.route(\"/path\")</code>)</li> <li>Providing a clean, object-oriented interface</li> <li>Following PEP 8 style conventions</li> <li>Leveraging Python's dynamic nature where appropriate</li> <li>Using type hints to improve developer experience</li> </ul>"},{"location":"development/design-philosophy/#5-extensibility","title":"5. Extensibility","text":"<p>While keeping the core simple, Plinx is designed to be extended and customized:</p> <ul> <li>The middleware system allows for flexible request/response processing</li> <li>Class-based views support inheritance and composition</li> <li>The ORM can be extended with custom methods and properties</li> <li>Core components are designed to be subclassed when needed</li> </ul>"},{"location":"development/design-philosophy/#design-decisions","title":"Design Decisions","text":""},{"location":"development/design-philosophy/#wsgi-foundation","title":"WSGI Foundation","text":"<p>Plinx is built on the WSGI standard rather than newer async frameworks (like ASGI) for several reasons:</p> <ol> <li>WSGI is simpler and more straightforward to understand</li> <li>It has wider support across servers and platforms</li> <li>It's sufficient for many web applications</li> <li>It provides a solid foundation for learning web framework concepts</li> </ol>"},{"location":"development/design-philosophy/#explicit-request-and-response-objects","title":"Explicit Request and Response Objects","text":"<p>Unlike some frameworks that use global request objects or return values as responses, Plinx explicitly passes request and response objects to handlers:</p> <pre><code>@app.route(\"/\")\ndef home(request, response):\n    response.text = \"Hello, World!\"\n</code></pre> <p>This design:</p> <ul> <li>Makes the flow of data more obvious</li> <li>Avoids hidden state and global variables</li> <li>Makes testing easier</li> <li>Simplifies understanding how requests and responses work</li> </ul>"},{"location":"development/design-philosophy/#lightweight-orm","title":"Lightweight ORM","text":"<p>The ORM in Plinx is intentionally lightweight:</p> <ul> <li>It focuses on the core CRUD operations</li> <li>It uses Python classes to define tables</li> <li>It provides a natural way to work with relationships</li> <li>It avoids complex query building or lazy loading</li> </ul> <p>This approach makes the ORM easy to learn and use, while still being useful for many applications.</p>"},{"location":"development/design-philosophy/#middleware-pattern","title":"Middleware Pattern","text":"<p>The middleware system follows a nested pattern instead of a linear chain. This design:</p> <ul> <li>Makes the request/response flow easy to understand</li> <li>Allows middleware to completely short-circuit the request if needed</li> <li>Provides symmetrical processing of requests and responses</li> <li>Follows established patterns in the Python web ecosystem</li> </ul>"},{"location":"development/design-philosophy/#tradeoffs","title":"Tradeoffs","text":"<p>Every design involves tradeoffs. Some conscious tradeoffs in Plinx include:</p>"},{"location":"development/design-philosophy/#performance-vs-clarity","title":"Performance vs. Clarity","text":"<p>In some cases, we've chosen more readable code over maximum performance optimizations. For example:</p> <ul> <li>The ORM prioritizes a clean API over raw SQL performance</li> <li>The routing system uses pattern matching for flexibility rather than fastest possible lookups</li> <li>The middleware chain is simple rather than highly optimized</li> </ul>"},{"location":"development/design-philosophy/#features-vs-focus","title":"Features vs. Focus","text":"<p>We've deliberately left out many features that larger frameworks provide:</p> <ul> <li>No built-in template rendering</li> <li>No form processing helpers</li> <li>No authentication/authorization system</li> <li>No admin interface</li> <li>Limited ORM query capabilities</li> </ul> <p>These omissions keep the framework focused and learnable, while allowing users to integrate third-party libraries when needed.</p>"},{"location":"development/design-philosophy/#flexibility-vs-convention","title":"Flexibility vs. Convention","text":"<p>Plinx provides less \"convention over configuration\" than some frameworks:</p> <ul> <li>No enforced project structure</li> <li>Minimal automatic configuration</li> <li>Few built-in defaults</li> </ul> <p>This gives users more freedom but requires more explicit choices.</p>"},{"location":"development/design-philosophy/#future-direction","title":"Future Direction","text":"<p>While maintaining the core principles, future versions of Plinx may explore:</p> <ul> <li>Optional ASGI support</li> <li>More sophisticated routing</li> <li>Enhanced ORM capabilities</li> <li>Minimal template integration</li> <li>Additional helper utilities</li> </ul> <p>However, any additions will be measured against the core principles to ensure Plinx remains true to its design philosophy.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Getting started with Plinx is simple, as it has minimal dependencies and can be installed in multiple ways.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>Plinx requires:</p> <ul> <li>Python 3.11 or newer</li> <li>A few core dependencies (automatically installed):<ul> <li><code>webob</code>: For WSGI request/response handling</li> <li><code>parse</code>: For URL pattern matching</li> </ul> </li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<p>The simplest way to install Plinx is via pip:</p> <pre><code>pip install Plinx\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>If you want the latest code or wish to contribute to Plinx, you can install directly from the source repository:</p> <pre><code>pip install git+https://github.com/dhavalsavalia/Plinx.git\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development purposes, clone the repository and install in development mode:</p> <pre><code>git clone https://github.com/dhavalsavalia/Plinx.git\ncd Plinx\npip install -e .\n</code></pre> <p>This will install the package in \"editable\" mode, meaning changes to the source code will be immediately reflected without needing to reinstall.</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>You can verify that Plinx has been installed correctly by running:</p> <pre><code>import plinx\nprint(plinx.__version__)  # Should print the current version\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For development and testing, you may want to install additional packages:</p> <pre><code># Install dev dependencies for testing, documentation, etc.\npip install requests requests-wsgi-adapter pytest pytest-cov flake8 twine mkdocs mkdocs-material mkdocstrings mkdocstrings-python\n</code></pre> <p>Or if you use pipenv:</p> <pre><code>pipenv install --dev\n</code></pre>"},{"location":"getting-started/installation/#running-with-a-wsgi-server","title":"Running with a WSGI Server","text":"<p>Plinx is a WSGI framework, so you'll need a WSGI server to run it in production. Gunicorn is a good choice:</p> <pre><code>pip install gunicorn\ngunicorn myapp:app\n</code></pre> <p>Where <code>myapp</code> is the module containing your Plinx application instance named <code>app</code>.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will help you create your first Plinx application in just a few minutes. We'll cover the basics of:</p> <ol> <li>Creating a simple application</li> <li>Adding routes</li> <li>Handling requests and responses</li> <li>Running your application</li> </ol>"},{"location":"getting-started/quick-start/#your-first-plinx-application","title":"Your First Plinx Application","text":"<p>Let's create a simple \"Hello, World!\" application:</p> <pre><code># app.py\nfrom plinx import Plinx\n\n# Create a new Plinx application\napp = Plinx()\n\n# Define a route using a decorator\n@app.route(\"/\")\ndef hello(request, response):\n    response.text = \"Hello, World!\"\n\nif __name__ == \"__main__\":\n    # For development only - not for production\n    from wsgiref.simple_server import make_server\n\n    print(\"Development server starting at http://localhost:8000...\")\n    server = make_server('localhost', 8000, app)\n    server.serve_forever()\n</code></pre> <p>Save this as <code>app.py</code> and run it:</p> <pre><code>python app.py\n</code></pre> <p>Visit http://localhost:8000/ in your browser to see \"Hello, World!\"</p>"},{"location":"getting-started/quick-start/#adding-more-routes","title":"Adding More Routes","text":"<p>Let's expand our application with more routes:</p> <pre><code># Text response\n@app.route(\"/about\")\ndef about(request, response):\n    response.text = \"About Plinx\"\n\n# JSON response\n@app.route(\"/api/info\")\ndef api_info(request, response):\n    response.json = {\n        \"name\": \"Plinx\",\n        \"version\": \"1.0.0\",\n        \"status\": \"OK\"\n    }\n\n# Dynamic URL parameters\n@app.route(\"/hello/{name}\")\ndef greet(request, response, name):\n    response.text = f\"Hello, {name}!\"\n</code></pre>"},{"location":"getting-started/quick-start/#http-methods","title":"HTTP Methods","text":"<p>Plinx supports different HTTP methods through specific decorators:</p> <pre><code>@app.get(\"/users\")\ndef get_users(request, response):\n    response.json = {\"users\": [\"user1\", \"user2\"]}\n\n@app.post(\"/users\")\ndef create_user(request, response):\n    # Access form data or JSON body from request\n    response.text = \"User created successfully\"\n    response.status_code = 201  # Created\n\n@app.put(\"/users/{user_id}\")\ndef update_user(request, response, user_id):\n    response.text = f\"User {user_id} updated\"\n\n@app.delete(\"/users/{user_id}\")\ndef delete_user(request, response, user_id):\n    response.text = f\"User {user_id} deleted\"\n</code></pre>"},{"location":"getting-started/quick-start/#class-based-views","title":"Class-Based Views","text":"<p>For resources that require multiple HTTP methods, you can use class-based views:</p> <pre><code>@app.route(\"/books\")\nclass BooksResource:\n    def get(self, request, response):\n        response.json = {\"books\": [\"Book 1\", \"Book 2\"]}\n\n    def post(self, request, response):\n        response.text = \"Book created\"\n        response.status_code = 201\n</code></pre>"},{"location":"getting-started/quick-start/#running-in-production","title":"Running in Production","text":"<p>For production deployment, use a WSGI server like Gunicorn:</p> <pre><code>pip install gunicorn\ngunicorn app:app\n</code></pre> <p>Or with custom options:</p> <pre><code>gunicorn app:app --workers=4 --bind=0.0.0.0:8000\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Middleware for request/response processing</li> <li>Explore the ORM for database operations</li> <li>Check out error handling techniques</li> <li>Browse the API Reference for detailed documentation</li> </ul>"},{"location":"orm/database-operations/","title":"Database Operations","text":"<p>This page explains how to perform common database operations using the Plinx ORM, including creating, retrieving, updating, and deleting records.</p>"},{"location":"orm/database-operations/#basic-crud-operations","title":"Basic CRUD Operations","text":"<p>CRUD stands for Create, Read, Update, and Delete - the four basic database operations you'll perform with the ORM.</p>"},{"location":"orm/database-operations/#connecting-to-a-database","title":"Connecting to a Database","text":"<p>First, establish a connection to your SQLite database:</p> <pre><code>from plinx.orm import Database\n\ndb = Database(\"my_app.db\")\n</code></pre> <p>This creates a new SQLite database file if it doesn't exist, or opens an existing one.</p>"},{"location":"orm/database-operations/#creating-records","title":"Creating Records","text":"<p>To create a new record in the database:</p> <ol> <li>Create an instance of your Table class</li> <li>Call the <code>save</code> method on the database</li> </ol> <pre><code>from plinx.orm import Database, Table, Column\n\ndb = Database(\"my_app.db\")\n\nclass User(Table):\n    name = Column(str)\n    email = Column(str)\n\ndb.create(User)  # Create the table if it doesn't exist\n\n# Create a new user\nuser = User(name=\"John Doe\", email=\"john@example.com\")\ndb.save(user)\n\n# The instance now has an id assigned\nprint(user.id)  # 1\n</code></pre>"},{"location":"orm/database-operations/#retrieving-records","title":"Retrieving Records","text":""},{"location":"orm/database-operations/#get-all-records","title":"Get All Records","text":"<p>To retrieve all records from a table:</p> <pre><code>users = db.all(User)\n\nfor user in users:\n    print(f\"User {user.id}: {user.name} ({user.email})\")\n</code></pre>"},{"location":"orm/database-operations/#get-a-single-record-by-id-or-criteria","title":"Get a Single Record by ID or Criteria","text":"<p>To retrieve a specific record by ID or other criteria:</p> <pre><code># Get by ID\nuser = db.get(User, id=1)\nprint(user.name)  # \"John Doe\"\n\n# Get by other criteria\nuser = db.get(User, email=\"john@example.com\")\nprint(user.name)  # \"John Doe\"\n</code></pre> <p>If no record matches the criteria, an exception is raised.</p>"},{"location":"orm/database-operations/#updating-records","title":"Updating Records","text":"<p>To update a record:</p> <ol> <li>Get the record from the database</li> <li>Modify its attributes</li> <li>Call the <code>update</code> method</li> </ol> <pre><code># Get the record\nuser = db.get(User, id=1)\n\n# Modify attributes\nuser.name = \"John Smith\"\nuser.email = \"johnsmith@example.com\"\n\n# Save changes\ndb.update(user)\n</code></pre>"},{"location":"orm/database-operations/#deleting-records","title":"Deleting Records","text":"<p>To delete a record:</p> <pre><code># Get the record\nuser = db.get(User, id=1)\n\n# Delete it\ndb.delete(user)\n</code></pre>"},{"location":"orm/database-operations/#working-with-relationships","title":"Working with Relationships","text":""},{"location":"orm/database-operations/#creating-related-records","title":"Creating Related Records","text":"<p>When working with related records, you can create them in a natural, object-oriented way:</p> <pre><code>from plinx.orm import Database, Table, Column, ForeignKey\n\ndb = Database(\"my_app.db\")\n\nclass Author(Table):\n    name = Column(str)\n\nclass Book(Table):\n    title = Column(str)\n    author = ForeignKey(Author)\n\ndb.create(Author)\ndb.create(Book)\n\n# Create an author\nauthor = Author(name=\"Jane Austen\")\ndb.save(author)\n\n# Create a book related to the author\nbook = Book(title=\"Pride and Prejudice\", author=author)\ndb.save(book)\n</code></pre>"},{"location":"orm/database-operations/#retrieving-related-records","title":"Retrieving Related Records","text":"<p>When you retrieve a record with foreign keys, the related objects are automatically loaded:</p> <pre><code># Get the book\nbook = db.get(Book, id=1)\n\n# Access the related author\nprint(book.title)       # \"Pride and Prejudice\"\nprint(book.author.name) # \"Jane Austen\"\n</code></pre>"},{"location":"orm/database-operations/#updating-relationships","title":"Updating Relationships","text":"<p>You can change relationships by assigning a different object:</p> <pre><code># Get two authors\nausten = db.get(Author, name=\"Jane Austen\")\ndickens = Author(name=\"Charles Dickens\")\ndb.save(dickens)\n\n# Get the book\nbook = db.get(Book, id=1)\n\n# Change the author\nbook.author = dickens\ndb.update(book)\n\n# Verify the change\nupdated_book = db.get(Book, id=1)\nprint(updated_book.author.name)  # \"Charles Dickens\"\n</code></pre>"},{"location":"orm/database-operations/#working-with-multiple-tables","title":"Working with Multiple Tables","text":""},{"location":"orm/database-operations/#creating-multiple-tables","title":"Creating Multiple Tables","text":"<p>You can create multiple tables in sequence:</p> <pre><code>from plinx.orm import Database, Table, Column, ForeignKey\n\ndb = Database(\"bookstore.db\")\n\nclass Publisher(Table):\n    name = Column(str)\n\nclass Author(Table):\n    name = Column(str)\n    bio = Column(str)\n\nclass Book(Table):\n    title = Column(str)\n    year = Column(int)\n    author = ForeignKey(Author)\n    publisher = ForeignKey(Publisher)\n\n# Create all tables\ndb.create(Publisher)\ndb.create(Author)\ndb.create(Book)\n</code></pre>"},{"location":"orm/database-operations/#complex-queries-and-filtering","title":"Complex Queries and Filtering","text":"<p>Currently, Plinx ORM supports basic filtering using the <code>get</code> method's keyword arguments:</p> <pre><code># Get a book with specific title\nbook = db.get(Book, title=\"Pride and Prejudice\")\n\n# Get a book by ID\nbook = db.get(Book, id=1)\n</code></pre> <p>For more complex queries, you would need to extend the ORM or use SQLite directly.</p>"},{"location":"orm/database-operations/#best-practices","title":"Best Practices","text":""},{"location":"orm/database-operations/#connection-management","title":"Connection Management","text":"<p>It's good practice to close the database connection when you're done with it:</p> <pre><code>db = Database(\"my_app.db\")\n# Use the database...\ndb.close()  # Close the connection when done\n</code></pre> <p>In web applications, you typically create the database connection when the app starts and close it when the app shuts down.</p>"},{"location":"orm/database-operations/#exception-handling","title":"Exception Handling","text":"<p>Handle exceptions when retrieving records that might not exist:</p> <pre><code>try:\n    user = db.get(User, email=\"nonexistent@example.com\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n    # Handle the case where the user doesn't exist\n</code></pre>"},{"location":"orm/database-operations/#batching-operations","title":"Batching Operations","text":"<p>For larger operations, you might want to batch your database calls:</p> <pre><code># Batch inserting users\nusers_data = [\n    {\"name\": \"User 1\", \"email\": \"user1@example.com\"},\n    {\"name\": \"User 2\", \"email\": \"user2@example.com\"},\n    {\"name\": \"User 3\", \"email\": \"user3@example.com\"},\n]\n\nfor data in users_data:\n    user = User(**data)\n    db.save(user)\n</code></pre>"},{"location":"orm/database-operations/#advanced-topics","title":"Advanced Topics","text":""},{"location":"orm/database-operations/#using-transactions","title":"Using Transactions","text":"<p>The Plinx ORM automatically handles transactions for individual operations. For custom transactions spanning multiple operations, you can use the SQLite connection directly:</p> <pre><code>try:\n    db.connection.execute(\"BEGIN TRANSACTION;\")\n\n    # Perform multiple operations\n    author = Author(name=\"Leo Tolstoy\")\n    db.save(author)\n\n    book1 = Book(title=\"War and Peace\", author=author)\n    db.save(book1)\n\n    book2 = Book(title=\"Anna Karenina\", author=author)\n    db.save(book2)\n\n    db.connection.execute(\"COMMIT;\")\nexcept Exception as e:\n    db.connection.execute(\"ROLLBACK;\")\n    print(f\"Transaction failed: {e}\")\n</code></pre>"},{"location":"orm/database-operations/#raw-sql-access","title":"Raw SQL Access","text":"<p>If you need functionality not provided by the ORM, you can execute raw SQL:</p> <pre><code># Execute a custom query\ncursor = db.connection.execute(\n    \"SELECT book.title, author.name FROM book JOIN author ON book.author_id = author.id\"\n)\nresults = cursor.fetchall()\n\nfor title, author_name in results:\n    print(f\"{title} by {author_name}\")\n</code></pre>"},{"location":"orm/database-operations/#table-introspection","title":"Table Introspection","text":"<p>You can get a list of all tables in the database:</p> <pre><code>tables = db.tables\nprint(f\"Database tables: {tables}\")\n</code></pre>"},{"location":"orm/database-operations/#limitations-and-future-enhancements","title":"Limitations and Future Enhancements","text":"<p>The current version of the Plinx ORM is intentionally minimalistic. Here are some features that might be added in future versions:</p> <ul> <li>More complex query capabilities (filtering, ordering, etc.)</li> <li>Support for table indexes and constraints</li> <li>Schema migration tools</li> <li>Lazy-loading of relationships</li> <li>Support for more database backends beyond SQLite</li> </ul>"},{"location":"orm/database-operations/#summary","title":"Summary","text":"<p>The Plinx ORM provides a simple, intuitive way to interact with SQLite databases using Python objects. While it lacks some features of more comprehensive ORMs, it offers a clean interface for basic CRUD operations and relationships that is perfect for small to medium-sized applications and educational purposes.</p>"},{"location":"orm/introduction/","title":"ORM Introduction","text":"<p>Plinx includes a lightweight Object-Relational Mapping (ORM) system that makes it easy to interact with SQLite databases. The ORM provides a clean, Pythonic interface for defining tables and performing database operations without writing raw SQL.</p>"},{"location":"orm/introduction/#key-features","title":"Key Features","text":"<ul> <li>Simple Table Definitions: Define database tables as Python classes</li> <li>Automatic Table Creation: Create tables from class definitions</li> <li>Intuitive CRUD Operations: Easy methods for creating, reading, updating, and deleting records</li> <li>Foreign Key Relationships: Define relationships between tables</li> <li>Type Mapping: Python types mapped to appropriate SQLite types</li> <li>No Raw SQL Required: Perform common operations without writing SQL</li> </ul>"},{"location":"orm/introduction/#basic-concepts","title":"Basic Concepts","text":"<p>The Plinx ORM consists of a few core components:</p> <ul> <li>Database: The main class for connecting to SQLite and performing operations</li> <li>Table: Base class for defining database tables</li> <li>Column: Class for defining table columns with Python types</li> <li>ForeignKey: Class for defining relationships between tables</li> </ul>"},{"location":"orm/introduction/#quick-example","title":"Quick Example","text":"<p>Here's a quick example of how to use the Plinx ORM:</p> <pre><code>from plinx.orm import Database, Table, Column, ForeignKey\n\n# Connect to a SQLite database\ndb = Database(\"my_app.db\")\n\n# Define tables\nclass Author(Table):\n    name = Column(str)\n    bio = Column(str)\n\nclass Book(Table):\n    title = Column(str)\n    year = Column(int)\n    author = ForeignKey(Author)\n\n# Create tables in the database\ndb.create(Author)\ndb.create(Book)\n\n# Create records\njk_rowling = Author(name=\"J.K. Rowling\", bio=\"British author...\")\ndb.save(jk_rowling)\n\nharry_potter = Book(\n    title=\"Harry Potter and the Philosopher's Stone\",\n    year=1997,\n    author=jk_rowling\n)\ndb.save(harry_potter)\n\n# Query records\nall_authors = db.all(Author)\nfor author in all_authors:\n    print(f\"Author: {author.name}\")\n\nall_books = db.all(Book)\nfor book in all_books:\n    print(f\"Book: {book.title} by {book.author.name}\")\n\n# Get a specific record\nbook = db.get(Book, id=1)\nprint(f\"Found book: {book.title}\")\n\n# Update a record\nbook.year = 1998\ndb.update(book)\n\n# Delete a record\ndb.delete(book)\n</code></pre>"},{"location":"orm/introduction/#when-to-use-the-plinx-orm","title":"When to Use the Plinx ORM","text":"<p>The Plinx ORM is ideal for:</p> <ul> <li>Small to medium-sized applications</li> <li>Prototyping and rapid development</li> <li>Educational purposes</li> <li>Projects where a full-featured ORM would be overkill</li> </ul> <p>It provides a balance between simplicity and power, allowing you to get started quickly without dealing with the complexity of larger ORMs.</p>"},{"location":"orm/introduction/#limitations","title":"Limitations","text":"<p>The Plinx ORM has some limitations compared to more robust ORMs like SQLAlchemy:</p> <ul> <li>SQLite Only: Currently only supports SQLite databases</li> <li>Limited Query API: No query builder or complex filtering</li> <li>No Migrations: No built-in schema migration system</li> <li>Limited Relationship Types: Only simple foreign keys are supported</li> <li>No Lazy Loading: All relationships are eagerly loaded</li> </ul> <p>These limitations are intentional to keep the ORM simple and focused. If you need more advanced features, consider using a more comprehensive ORM.</p>"},{"location":"orm/introduction/#next-steps","title":"Next Steps","text":"<p>In the next sections, we'll explore how to:</p> <ul> <li>Define tables and columns in detail</li> <li>Work with foreign key relationships</li> <li>Perform CRUD operations</li> <li>Handle common database patterns</li> </ul> <p>Let's start with Tables &amp; Models.</p>"},{"location":"orm/tables-and-models/","title":"Tables &amp; Models","text":"<p>In the Plinx ORM, database tables are represented as Python classes that inherit from the <code>Table</code> base class. This page explains how to define tables, columns, and relationships for your database.</p>"},{"location":"orm/tables-and-models/#defining-tables","title":"Defining Tables","text":"<p>To define a database table, create a class that inherits from <code>Table</code>:</p> <pre><code>from plinx.orm import Table, Column\n\nclass User(Table):\n    name = Column(str)\n    email = Column(str)\n    age = Column(int)\n    is_active = Column(bool)\n</code></pre> <p>This code defines a <code>User</code> table with columns for <code>name</code>, <code>email</code>, <code>age</code>, and <code>is_active</code>. Each column is defined using the <code>Column</code> class with a Python type that determines the corresponding SQLite type.</p>"},{"location":"orm/tables-and-models/#column-types","title":"Column Types","text":"<p>Plinx ORM maps Python types to SQLite types as follows:</p> Python Type SQLite Type <code>str</code> TEXT <code>int</code> INTEGER <code>float</code> REAL <code>bool</code> INTEGER <code>bytes</code> BLOB <p>For example:</p> <pre><code>class Product(Table):\n    name = Column(str)          # TEXT\n    price = Column(float)       # REAL\n    stock = Column(int)         # INTEGER\n    is_available = Column(bool) # INTEGER (0 or 1)\n    image_data = Column(bytes)  # BLOB\n</code></pre>"},{"location":"orm/tables-and-models/#creating-tables-in-the-database","title":"Creating Tables in the Database","text":"<p>After defining your table classes, you need to create them in the database:</p> <pre><code>from plinx.orm import Database\n\ndb = Database(\"my_app.db\")  # Connect to SQLite database\n\n# Create tables\ndb.create(User)\ndb.create(Product)\n</code></pre> <p>The <code>create</code> method generates and executes the appropriate SQL <code>CREATE TABLE</code> statement based on your class definition. If the table already exists, it won't be recreated (Plinx uses <code>CREATE TABLE IF NOT EXISTS</code>).</p>"},{"location":"orm/tables-and-models/#primary-keys","title":"Primary Keys","text":"<p>Every table automatically gets an auto-incrementing integer primary key column named <code>id</code>. You don't need to define this yourself:</p> <pre><code>user = User(name=\"John\", email=\"john@example.com\", age=30, is_active=True)\ndb.save(user)\nprint(user.id)  # Automatically assigned after saving\n</code></pre>"},{"location":"orm/tables-and-models/#relationships","title":"Relationships","text":"<p>To define relationships between tables, use the <code>ForeignKey</code> class:</p> <pre><code>from plinx.orm import Table, Column, ForeignKey\n\nclass Category(Table):\n    name = Column(str)\n    description = Column(str)\n\nclass Product(Table):\n    name = Column(str)\n    price = Column(float)\n    category = ForeignKey(Category)  # Reference to Category\n</code></pre> <p>This creates a foreign key from <code>Product</code> to <code>Category</code>. Behind the scenes, Plinx creates a <code>category_id</code> column in the <code>Product</code> table that references the <code>id</code> column in the <code>Category</code> table.</p> <p>When you retrieve a <code>Product</code> from the database, its <code>category</code> attribute will be a fully loaded <code>Category</code> instance:</p> <pre><code># Create a category\nelectronics = Category(name=\"Electronics\", description=\"Electronic devices\")\ndb.save(electronics)\n\n# Create a product with a reference to the category\nphone = Product(name=\"Smartphone\", price=599.99, category=electronics)\ndb.save(phone)\n\n# Retrieve the product\nproduct = db.get(Product, id=1)\nprint(product.name)            # \"Smartphone\"\nprint(product.category.name)   # \"Electronics\"\n</code></pre>"},{"location":"orm/tables-and-models/#creating-instances","title":"Creating Instances","text":"<p>To create a new record, instantiate your table class with keyword arguments for each column:</p> <pre><code>user = User(\n    name=\"Alice Smith\",\n    email=\"alice@example.com\",\n    age=25,\n    is_active=True\n)\n</code></pre> <p>All attributes are optional during instantiation. If not provided, they'll be set to <code>None</code>:</p> <pre><code># Partial instantiation\nuser = User(name=\"Bob Johnson\")\nprint(user.email)  # None\n</code></pre>"},{"location":"orm/tables-and-models/#attribute-access","title":"Attribute Access","text":"<p>You can access and modify attributes as normal Python properties:</p> <pre><code>user = User(name=\"Charlie Brown\")\nprint(user.name)  # \"Charlie Brown\"\n\nuser.name = \"Charlie B. Brown\"\nuser.age = 32\n</code></pre>"},{"location":"orm/tables-and-models/#table-names","title":"Table Names","text":"<p>By default, the table name in the database is the lowercase version of your class name:</p> <ul> <li><code>User</code> class \u2192 <code>user</code> table</li> <li><code>Product</code> class \u2192 <code>product</code> table</li> <li><code>OrderItem</code> class \u2192 <code>orderitem</code> table</li> </ul>"},{"location":"orm/tables-and-models/#the-model-pattern","title":"The Model Pattern","text":"<p>While the ORM doesn't enforce a strict MVC (Model-View-Controller) pattern, your <code>Table</code> classes essentially function as models. It's a good practice to include business logic related to your data in these classes:</p> <pre><code>class User(Table):\n    name = Column(str)\n    email = Column(str)\n    age = Column(int)\n\n    def is_adult(self):\n        return self.age &gt;= 18\n\n    def get_display_name(self):\n        return self.name.split()[0]  # Return first name\n</code></pre> <p>This encapsulates behavior with data, following good object-oriented design principles.</p>"},{"location":"orm/tables-and-models/#best-practices","title":"Best Practices","text":"<ol> <li>Class names should be singular: Use <code>User</code>, not <code>Users</code></li> <li>Use descriptive names: Choose clear, descriptive names for tables and columns</li> <li>Keep models organized: Group related models in the same module/file</li> <li>Define relationships explicitly: Use <code>ForeignKey</code> to make relationships clear</li> <li>Add business logic: Include methods that encapsulate business rules</li> </ol>"},{"location":"orm/tables-and-models/#limitations","title":"Limitations","text":"<p>The current Plinx ORM implementation has a few limitations to be aware of:</p> <ul> <li>No support for composite primary keys</li> <li>No built-in schema migrations</li> <li>No support for complex SQL features like indexes, unique constraints, etc.</li> <li>No support for many-to-many relationships without an explicit join table</li> </ul> <p>These limitations help keep the ORM simple and focused while still being useful for many common scenarios.</p>"},{"location":"orm/tables-and-models/#next-steps","title":"Next Steps","text":"<p>Now that you understand how to define tables and models, let's look at how to perform database operations with the Plinx ORM.</p>"},{"location":"user-guide/class-based-views/","title":"Class-Based Views","text":"<p>Class-based views in Plinx provide an object-oriented approach to organizing your request handlers. This guide explains how to implement and use class-based views effectively.</p>"},{"location":"user-guide/class-based-views/#introduction-to-class-based-views","title":"Introduction to Class-Based Views","text":"<p>While function-based views are simple and straightforward, class-based views offer several advantages:</p> <ol> <li>Organization: Group related endpoint handlers by HTTP method</li> <li>Code reuse: Share functionality through inheritance</li> <li>State management: Store and access shared state across methods</li> <li>Cleaner structure: Separate handlers for different HTTP methods</li> </ol>"},{"location":"user-guide/class-based-views/#basic-usage","title":"Basic Usage","text":"<p>Creating a class-based view is simple:</p> <pre><code>from plinx import Plinx\n\napp = Plinx()\n\n@app.route(\"/books\")\nclass BookResource:\n    def get(self, request, response):\n        response.json = {\"books\": [\"Book 1\", \"Book 2\", \"Book 3\"]}\n\n    def post(self, request, response):\n        response.status_code = 201\n        response.json = {\"message\": \"Book created successfully\"}\n</code></pre> <p>Plinx will automatically dispatch requests to the appropriate method based on the HTTP method:</p> <ul> <li><code>GET</code> requests to <code>/books</code> will call the <code>get</code> method</li> <li><code>POST</code> requests to <code>/books</code> will call the <code>post</code> method</li> <li>Requests with unsupported methods will receive a 405 Method Not Allowed response</li> </ul>"},{"location":"user-guide/class-based-views/#http-method-support","title":"HTTP Method Support","text":"<p>Class-based views can implement handlers for any HTTP method by defining corresponding methods:</p> <pre><code>@app.route(\"/resource\")\nclass CompleteResource:\n    def get(self, request, response):\n        # Handle GET requests\n        response.text = \"GET request processed\"\n\n    def post(self, request, response):\n        # Handle POST requests\n        response.text = \"POST request processed\"\n\n    def put(self, request, response):\n        # Handle PUT requests\n        response.text = \"PUT request processed\"\n\n    def delete(self, request, response):\n        # Handle DELETE requests\n        response.text = \"DELETE request processed\"\n\n    def patch(self, request, response):\n        # Handle PATCH requests\n        response.text = \"PATCH request processed\"\n\n    def head(self, request, response):\n        # Handle HEAD requests\n        # Note: No body is returned for HEAD requests\n\n    def options(self, request, response):\n        # Handle OPTIONS requests\n        response.headers[\"Allow\"] = \"GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS\"\n        response.text = \"\"\n</code></pre>"},{"location":"user-guide/class-based-views/#url-parameters-with-class-based-views","title":"URL Parameters with Class-Based Views","text":"<p>URL parameters work the same way as with function-based views:</p> <pre><code>@app.route(\"/books/{book_id:d}\")\nclass BookDetailResource:\n    def get(self, request, response, book_id):\n        response.json = {\"book_id\": book_id, \"title\": f\"Book {book_id}\"}\n\n    def put(self, request, response, book_id):\n        response.json = {\"message\": f\"Book {book_id} updated\"}\n\n    def delete(self, request, response, book_id):\n        response.json = {\"message\": f\"Book {book_id} deleted\"}\n</code></pre>"},{"location":"user-guide/class-based-views/#reusing-code-with-inheritance","title":"Reusing Code with Inheritance","text":"<p>One of the major advantages of class-based views is the ability to share code through inheritance:</p> <pre><code># Base class with common functionality\nclass BaseResourceView:\n    def get_current_user(self, request):\n        auth_token = request.headers.get(\"Authorization\", \"\")\n        if auth_token.startswith(\"Bearer \"):\n            # Validate token and return user (implementation details omitted)\n            return {\"id\": 123, \"username\": \"example_user\"}\n        return None\n\n    def check_authentication(self, request, response):\n        user = self.get_current_user(request)\n        if user is None:\n            response.status_code = 401\n            response.json = {\"error\": \"Authentication required\"}\n            return False\n        request.user = user\n        return True\n\n# Implement a protected resource using the base class\n@app.route(\"/profile\")\nclass ProfileResource(BaseResourceView):\n    def get(self, request, response):\n        if not self.check_authentication(request, response):\n            return  # Authentication failed, response already set\n\n        response.json = {\n            \"profile\": {\n                \"id\": request.user[\"id\"],\n                \"username\": request.user[\"username\"]\n            }\n        }\n</code></pre>"},{"location":"user-guide/class-based-views/#initialization-and-state","title":"Initialization and State","text":"<p>Class-based views are instantiated once per request, allowing you to maintain state during the request lifecycle:</p> <pre><code>@app.route(\"/stateful\")\nclass StatefulResource:\n    def __init__(self):\n        self.start_time = time.time()\n        self.operations = []\n\n    def get(self, request, response):\n        self.operations.append(\"GET\")\n        processing_time = time.time() - self.start_time\n\n        response.json = {\n            \"operations\": self.operations,\n            \"processing_time\": f\"{processing_time:.6f} seconds\"\n        }\n\n    def post(self, request, response):\n        self.operations.append(\"POST\")\n        # Process the request\n        response.json = {\"operations\": self.operations}\n</code></pre>"},{"location":"user-guide/class-based-views/#handling-different-content-types","title":"Handling Different Content Types","text":"<p>Class-based views can implement specialized methods for handling different content types:</p> <pre><code>@app.route(\"/api/data\")\nclass DataResource:\n    def get(self, request, response):\n        content_type = request.headers.get(\"Accept\", \"application/json\")\n\n        data = {\"name\": \"Example\", \"value\": 42}\n\n        if \"application/xml\" in content_type:\n            self.respond_with_xml(response, data)\n        else:\n            self.respond_with_json(response, data)\n\n    def respond_with_json(self, response, data):\n        response.json = data\n\n    def respond_with_xml(self, response, data):\n        # Convert data to XML (simplified example)\n        xml = f\"&lt;data&gt;&lt;name&gt;{data['name']}&lt;/name&gt;&lt;value&gt;{data['value']}&lt;/value&gt;&lt;/data&gt;\"\n        response.text = xml\n        response.content_type = \"application/xml\"\n</code></pre>"},{"location":"user-guide/class-based-views/#mixins-for-common-functionality","title":"Mixins for Common Functionality","text":"<p>Mixins are a powerful way to compose functionality into your class-based views:</p> <pre><code># Authentication mixin\nclass AuthMixin:\n    def authenticate(self, request, response):\n        # Authentication logic\n        pass\n\n# Logging mixin\nclass LoggingMixin:\n    def log_request(self, request):\n        print(f\"Request received: {request.method} {request.path}\")\n\n    def log_response(self, response):\n        print(f\"Response generated: {response.status_code}\")\n\n# Cache control mixin\nclass CacheControlMixin:\n    def add_cache_headers(self, response, max_age=3600):\n        response.headers[\"Cache-Control\"] = f\"max-age={max_age}\"\n\n# Combined resource using mixins\n@app.route(\"/api/items\")\nclass ItemResource(AuthMixin, LoggingMixin, CacheControlMixin):\n    def get(self, request, response):\n        self.log_request(request)\n\n        if not self.authenticate(request, response):\n            return\n\n        response.json = {\"items\": [\"Item 1\", \"Item 2\"]}\n\n        self.add_cache_headers(response, max_age=60)\n        self.log_response(response)\n</code></pre>"},{"location":"user-guide/class-based-views/#best-practices","title":"Best Practices","text":"<ol> <li>Keep classes focused: Each class should have a clear responsibility</li> <li>Use inheritance carefully: Deep inheritance hierarchies can be hard to understand</li> <li>Consider mixins for reusable, composable functionality</li> <li>Document method requirements: Make it clear what each method expects and returns</li> <li>Be consistent with method signatures: All handler methods should take the same parameters</li> <li>Use helper methods: Extract common functionality into helper methods</li> <li>Remember that classes are instantiated per request: Don't rely on state being preserved between requests</li> </ol> <p>Class-based views provide a powerful way to organize your application logic. By following these best practices, you can create clean, maintainable, and reusable request handlers in your Plinx applications.</p>"},{"location":"user-guide/core-concepts/","title":"Core Concepts","text":"<p>This page explains the fundamental concepts and design principles behind Plinx.</p>"},{"location":"user-guide/core-concepts/#architecture-overview","title":"Architecture Overview","text":"<p>Plinx follows the WSGI (Web Server Gateway Interface) standard, which defines a simple and universal interface between web servers and Python web applications. The architecture consists of:</p> <ul> <li>WSGI Application: The <code>Plinx</code> class implements the WSGI callable interface</li> <li>Request Handling: Converts raw WSGI environment to convenient request objects</li> <li>Routing: Maps URL patterns to handler functions or classes</li> <li>Middleware: Processes requests/responses before/after handler execution</li> <li>Response Generation: Converts handler output to proper HTTP responses</li> </ul>"},{"location":"user-guide/core-concepts/#the-request-response-cycle","title":"The Request-Response Cycle","text":"<p>Here's how a typical request flows through Plinx:</p> <ol> <li>The WSGI server calls the Plinx application with environment and start_response</li> <li>Middleware processes the incoming request</li> <li>The router finds the appropriate handler for the URL path</li> <li>The handler function/method is executed with the request and response objects</li> <li>Middleware processes the response</li> <li>The response is returned to the WSGI server</li> </ol>"},{"location":"user-guide/core-concepts/#routing-system","title":"Routing System","text":"<p>The routing system in Plinx maps URL patterns to handler functions or classes. Key features include:</p> <ul> <li>Path Parameters: Routes can include parameters in braces like <code>/users/{id}</code></li> <li>Method-Specific Routes: Decorate handlers with <code>@app.get()</code>, <code>@app.post()</code>, etc.</li> <li>Class-Based Views: Route to classes with methods named after HTTP methods</li> </ul>"},{"location":"user-guide/core-concepts/#function-based-vs-class-based-handlers","title":"Function-Based vs. Class-Based Handlers","text":""},{"location":"user-guide/core-concepts/#function-based-handlers","title":"Function-Based Handlers","text":"<pre><code>@app.route(\"/hello\")\ndef hello_handler(request, response):\n    response.text = \"Hello, World!\"\n</code></pre> <p>Function-based handlers are simple and straightforward. They're ideal for: - Simple endpoints with a single HTTP method - Quick prototyping - Stateless request processing</p>"},{"location":"user-guide/core-concepts/#class-based-handlers","title":"Class-Based Handlers","text":"<pre><code>@app.route(\"/users\")\nclass UserResource:\n    def get(self, request, response):\n        response.text = \"List users\"\n\n    def post(self, request, response):\n        response.text = \"Create user\"\n</code></pre> <p>Class-based handlers are powerful for: - Resources that respond to multiple HTTP methods - Organizing related endpoints - Reusing common functionality</p>"},{"location":"user-guide/core-concepts/#response-building","title":"Response Building","text":"<p>Plinx provides a clean interface for building responses:</p> <ul> <li>Text responses: <code>response.text = \"Hello, World!\"</code></li> <li>JSON responses: <code>response.json = {\"key\": \"value\"}</code></li> <li>Status codes: <code>response.status_code = 200</code></li> <li>Custom headers: <code>response.headers[\"X-Custom\"] = \"Value\"</code></li> </ul>"},{"location":"user-guide/core-concepts/#middleware","title":"Middleware","text":"<p>Middleware allows you to process requests and responses globally:</p> <pre><code>class SimpleMiddleware(Middleware):\n    def process_request(self, request):\n        # Process before request reaches handler\n        request.middleware_was_here = True\n\n    def process_response(self, request, response):\n        # Process after handler generates response\n        response.headers[\"X-Processed-By\"] = \"SimpleMiddleware\"\n</code></pre> <p>Common middleware use cases: - Authentication and authorization - Logging - CORS handling - Request/response transformation</p>"},{"location":"user-guide/core-concepts/#design-principles","title":"Design Principles","text":"<p>Plinx was built with the following principles in mind:</p> <ol> <li>Simplicity: Clean API without unnecessary complexity</li> <li>Explicitness: Clear and readable code with minimal \"magic\"</li> <li>Lightweight: Small core with minimal dependencies</li> <li>Extensibility: Easy to extend and customize</li> <li>Educational Value: Clear implementation for learning purposes</li> </ol> <p>These principles guide the development of Plinx and inform its design decisions.</p>"},{"location":"user-guide/error-handling/","title":"Error Handling","text":"<p>Proper error handling is crucial for building robust web applications. This guide explains how to handle errors in Plinx applications, from simple exception handling to more complex error management strategies.</p>"},{"location":"user-guide/error-handling/#built-in-error-handling","title":"Built-in Error Handling","text":""},{"location":"user-guide/error-handling/#default-error-responses","title":"Default Error Responses","text":"<p>By default, Plinx handles errors in the following way:</p> <ol> <li>If a route handler raises an exception, Plinx catches it and:</li> <li>Sets the response status code to 500 (Internal Server Error)</li> <li> <p>Sets the response text to the exception's string representation</p> </li> <li> <p>If no route matches the requested URL, Plinx:</p> </li> <li>Sets the response status code to 404 (Not Found)</li> <li> <p>Sets the response text to \"Not Found\"</p> </li> <li> <p>If a route is matched but the HTTP method is not supported, Plinx:</p> </li> <li>Sets the response status code to 405 (Method Not Allowed)</li> <li>Sets the response text to \"Method Not Allowed\"</li> </ol>"},{"location":"user-guide/error-handling/#custom-exception-handler","title":"Custom Exception Handler","text":"<p>You can override the default exception handling by registering a custom exception handler:</p> <pre><code>def custom_exception_handler(request, response, exception):\n    \"\"\"Handle all exceptions in the application.\"\"\"\n    response.status_code = 500\n    response.json = {\n        \"error\": str(exception),\n        \"type\": exception.__class__.__name__\n    }\n\n    # You can also log the exception\n    import traceback\n    print(f\"Exception: {exception}\")\n    print(traceback.format_exc())\n\napp = Plinx()\napp.add_exception_handler(custom_exception_handler)\n</code></pre> <p>This handler will be called whenever an uncaught exception occurs in a route handler.</p>"},{"location":"user-guide/error-handling/#handling-specific-exceptions","title":"Handling Specific Exceptions","text":"<p>To handle specific exception types differently, you can check the exception type in your handler:</p> <pre><code>def exception_handler(request, response, exception):\n    if isinstance(exception, ValueError):\n        response.status_code = 400  # Bad Request\n        response.json = {\"error\": \"Invalid input\", \"details\": str(exception)}\n    elif isinstance(exception, PermissionError):\n        response.status_code = 403  # Forbidden\n        response.json = {\"error\": \"Permission denied\"}\n    elif isinstance(exception, FileNotFoundError):\n        response.status_code = 404  # Not Found\n        response.json = {\"error\": \"Resource not found\"}\n    else:\n        response.status_code = 500  # Internal Server Error\n        response.json = {\"error\": \"An unexpected error occurred\"}\n\n    # Log the error\n    print(f\"Error: {exception.__class__.__name__}: {exception}\")\n\napp.add_exception_handler(exception_handler)\n</code></pre>"},{"location":"user-guide/error-handling/#custom-error-classes","title":"Custom Error Classes","text":"<p>You can define custom error classes to make your error handling more structured:</p> <pre><code>class APIError(Exception):\n    \"\"\"Base class for API errors.\"\"\"\n    status_code = 500\n\n    def __init__(self, message, status_code=None, payload=None):\n        super().__init__(message)\n        self.message = message\n        if status_code is not None:\n            self.status_code = status_code\n        self.payload = payload or {}\n\n    def to_dict(self):\n        error_dict = dict(self.payload)\n        error_dict['message'] = self.message\n        error_dict['status'] = self.status_code\n        return error_dict\n\nclass BadRequestError(APIError):\n    \"\"\"Error for invalid client requests.\"\"\"\n    status_code = 400\n\nclass NotFoundError(APIError):\n    \"\"\"Error for resources that don't exist.\"\"\"\n    status_code = 404\n</code></pre> <p>Then handle these custom errors in your exception handler:</p> <pre><code>def api_exception_handler(request, response, exception):\n    if isinstance(exception, APIError):\n        response.status_code = exception.status_code\n        response.json = exception.to_dict()\n    else:\n        response.status_code = 500\n        response.json = {\n            \"message\": \"An unexpected error occurred\",\n            \"status\": 500\n        }\n\napp.add_exception_handler(api_exception_handler)\n</code></pre> <p>In your handlers, you can raise these custom errors:</p> <pre><code>@app.route(\"/users/{user_id}\")\ndef get_user(request, response, user_id):\n    try:\n        user_id = int(user_id)\n    except ValueError:\n        raise BadRequestError(\"User ID must be a number\")\n\n    user = get_user_from_database(user_id)\n    if user is None:\n        raise NotFoundError(f\"User {user_id} not found\")\n\n    response.json = {\"id\": user_id, \"name\": user[\"name\"]}\n</code></pre>"},{"location":"user-guide/error-handling/#error-handling-with-middleware","title":"Error Handling with Middleware","text":"<p>You can also use middleware for error handling, which gives you more control over the request/response cycle:</p> <pre><code>from plinx.middleware import Middleware\n\nclass ErrorHandlingMiddleware(Middleware):\n    def process_request(self, request):\n        # You could add request validation here\n        pass\n\n    def process_response(self, request, response):\n        # You could modify error responses here\n        if response.status_code &gt;= 400:\n            response.headers[\"X-Error\"] = \"true\"\n\n            # For API requests, ensure JSON response\n            if request.path.startswith(\"/api/\"):\n                if not isinstance(response.json, dict):\n                    response.json = {\"error\": response.text or \"An error occurred\"}\n\napp.add_middleware(ErrorHandlingMiddleware)\n</code></pre>"},{"location":"user-guide/error-handling/#handling-404-errors","title":"Handling 404 Errors","text":"<p>To customize the 404 Not Found response, you can add a catch-all route at the end of your routes:</p> <pre><code># Add all your normal routes first\n\n# Then add a catch-all route\n@app.route(\"/{path}\")\ndef not_found(request, response, path=None):\n    response.status_code = 404\n    response.json = {\n        \"error\": \"Not Found\",\n        \"path\": request.path\n    }\n</code></pre> <p>Note: This approach works because Plinx tries routes in the order they were added, and the path parameter in this route will match any single path segment. For more complex catch-all behavior, you might need a more sophisticated approach.</p>"},{"location":"user-guide/error-handling/#handling-method-not-allowed","title":"Handling Method Not Allowed","text":"<p>For class-based views, you can explicitly handle unsupported methods:</p> <pre><code>@app.route(\"/resources/{id}\")\nclass ResourceHandler:\n    def get(self, request, response, id):\n        response.json = {\"id\": id, \"name\": f\"Resource {id}\"}\n\n    def put(self, request, response, id):\n        response.text = f\"Updated resource {id}\"\n\n    def options(self, request, response, id):\n        # Explicitly handle OPTIONS requests\n        response.headers[\"Allow\"] = \"GET, PUT, OPTIONS\"\n        response.status_code = 204  # No Content\n</code></pre>"},{"location":"user-guide/error-handling/#logging-errors","title":"Logging Errors","text":"<p>It's a good practice to log errors for debugging and monitoring. You can integrate with Python's logging module:</p> <pre><code>import logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    filename='app.log'\n)\nlogger = logging.getLogger('plinx_app')\n\ndef exception_handler(request, response, exception):\n    # Log the exception with context\n    logger.exception(\n        f\"Error handling request {request.method} {request.path}: {exception}\"\n    )\n\n    # Set the response\n    response.status_code = 500\n    response.json = {\"error\": \"An unexpected error occurred\"}\n\napp.add_exception_handler(exception_handler)\n</code></pre>"},{"location":"user-guide/error-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Always handle exceptions: Never let exceptions propagate to the user without being caught and handled properly</li> <li>Provide useful error messages: Make error responses informative but be careful not to expose sensitive information</li> <li>Use appropriate status codes: Choose the HTTP status code that best represents the error condition</li> <li>Log errors with context: Include enough information in logs to understand and reproduce the issue</li> <li>Consider security implications: Don't expose sensitive details in error messages sent to clients</li> <li>Be consistent: Use a consistent error response format throughout your API</li> </ol>"},{"location":"user-guide/handling-requests/","title":"Handling Requests","text":"<p>Plinx provides a flexible and intuitive way to handle HTTP requests. This guide explains how request handling works and shows various techniques for working with requests and responses.</p>"},{"location":"user-guide/handling-requests/#request-flow","title":"Request Flow","text":"<p>When a request arrives at your Plinx application, it goes through the following flow:</p> <ol> <li>The WSGI server passes the request to the Plinx application</li> <li>The request passes through any configured middleware (see Middleware)</li> <li>Plinx tries to match the request path with registered routes</li> <li>If a matching route is found, the appropriate handler is called</li> <li>The handler generates a response</li> <li>The response passes back through middleware</li> <li>The response is returned to the client</li> </ol>"},{"location":"user-guide/handling-requests/#request-object","title":"Request Object","text":"<p>The request object is an instance of <code>webob.Request</code> and provides access to all the information about the incoming HTTP request:</p> <pre><code>@app.route(\"/example\")\ndef handler(request, response):\n    # Access request properties\n    method = request.method  # GET, POST, etc.\n    path = request.path      # /example\n    query = request.GET      # Query parameters\n    form = request.POST      # Form data\n    json = request.json      # JSON body (if Content-Type is application/json)\n    headers = request.headers  # Headers dictionary\n</code></pre>"},{"location":"user-guide/handling-requests/#common-request-properties","title":"Common Request Properties","text":"Property Description <code>request.method</code> HTTP method (GET, POST, etc.) <code>request.path</code> Request path <code>request.GET</code> Dictionary-like object containing query parameters <code>request.POST</code> Dictionary-like object containing form data <code>request.json</code> Parsed JSON body (if Content-Type is application/json) <code>request.headers</code> Dictionary-like object containing HTTP headers <code>request.cookies</code> Dictionary-like object containing cookies <code>request.body</code> Raw request body as bytes"},{"location":"user-guide/handling-requests/#response-object","title":"Response Object","text":"<p>The response object is an instance of <code>plinx.response.PlinxResponse</code> and allows you to set the response data:</p> <pre><code>@app.route(\"/example\")\ndef handler(request, response):\n    # Set response properties\n    response.text = \"Hello, World!\"  # Plain text response\n    response.status_code = 200       # HTTP status code\n    response.headers[\"X-Custom\"] = \"Value\"  # Custom header\n</code></pre>"},{"location":"user-guide/handling-requests/#response-helpers","title":"Response Helpers","text":"<p>Plinx provides several helper properties to make setting responses easier:</p>"},{"location":"user-guide/handling-requests/#text-response","title":"Text Response","text":"<pre><code>@app.route(\"/text\")\ndef text_handler(request, response):\n    response.text = \"Hello, Text!\"\n    # Content-Type will be automatically set to text/plain\n</code></pre>"},{"location":"user-guide/handling-requests/#json-response","title":"JSON Response","text":"<pre><code>@app.route(\"/json\")\ndef json_handler(request, response):\n    response.json = {\"message\": \"Hello, JSON!\"}\n    # Content-Type will be automatically set to application/json\n</code></pre>"},{"location":"user-guide/handling-requests/#custom-response-body","title":"Custom Response Body","text":"<pre><code>@app.route(\"/custom\")\ndef custom_handler(request, response):\n    response.body = b\"Hello, World as bytes!\"\n    response.content_type = \"text/plain\"\n</code></pre>"},{"location":"user-guide/handling-requests/#class-based-views","title":"Class-Based Views","text":"<p>Plinx supports class-based views for organizing handlers by HTTP method:</p> <pre><code>@app.route(\"/books\")\nclass BooksResource:\n    def get(self, req, resp):\n        resp.text = \"Get all books\"\n\n    def post(self, req, resp):\n        resp.text = \"Create a new book\"\n\n    def put(self, req, resp):\n        resp.text = \"Update a book\"\n\n    def delete(self, req, resp):\n        resp.text = \"Delete a book\"\n</code></pre> <p>Class-based views automatically map HTTP methods to corresponding method names. If a method is not defined, a 405 Method Not Allowed response will be returned.</p>"},{"location":"user-guide/handling-requests/#url-parameters","title":"URL Parameters","text":"<p>Plinx supports dynamic URL parameters with type conversion:</p> <pre><code>@app.route(\"/users/{user_id:d}\")  # :d converts to integer\ndef user_detail(request, response, user_id):\n    response.text = f\"User ID: {user_id} (type: {type(user_id).__name__})\"\n\n@app.route(\"/posts/{slug}\")  # String parameter (default)\ndef post_detail(request, response, slug):\n    response.text = f\"Post slug: {slug}\"\n\n@app.route(\"/math/{operation}/{num_1:d}/{num_2:d}\")  # Multiple parameters\ndef calculate(request, response, operation, num_1, num_2):\n    if operation == \"add\":\n        result = num_1 + num_2\n    # ... other operations\n    response.text = f\"Result: {result}\"\n</code></pre>"},{"location":"user-guide/handling-requests/#error-handling","title":"Error Handling","text":"<p>Plinx provides a mechanism for handling exceptions at the application level:</p> <pre><code>def custom_exception_handler(request, response, exception_cls):\n    response.text = f\"Error: {str(exception_cls)}\"\n    response.status_code = 500  # Or an appropriate status code\n\napp.add_exception_handler(custom_exception_handler)\n\n@app.route(\"/error\")\ndef error_handler(request, response):\n    raise ValueError(\"Something went wrong\")  # Will be handled by exception handler\n</code></pre> <p>For more details on error handling, see the Error Handling guide.</p>"},{"location":"user-guide/handling-requests/#best-practices","title":"Best Practices","text":"<ol> <li>Keep handlers focused: Each handler should have a single responsibility</li> <li>Use class-based views for resource-oriented endpoints</li> <li>Set appropriate status codes: Use standard HTTP status codes for different situations</li> <li>Validate input data: Always validate and sanitize user input</li> <li>Handle exceptions gracefully: Use exception handling to provide meaningful error messages</li> <li>Use middleware for cross-cutting concerns like authentication or logging</li> <li>Return consistent response formats: Standardize your API response structure</li> </ol> <p>By following these principles, you can build maintainable and robust request handlers in your Plinx applications.</p>"},{"location":"user-guide/middleware/","title":"Middleware","text":"<p>Middleware in Plinx provides a powerful mechanism to process requests and responses at a global level. This guide explains how middleware works and how to create your own middleware components.</p>"},{"location":"user-guide/middleware/#what-is-middleware","title":"What is Middleware?","text":"<p>Middleware are components that \"wrap\" around your application to process requests before they reach your handlers and responses before they're returned to the client. They form a nested structure, like layers of an onion, with each middleware having the opportunity to:</p> <ol> <li>Process the request before it reaches the next middleware or handler</li> <li>Process the response after it's generated but before it reaches the client</li> </ol> <p>This pattern enables cross-cutting concerns like authentication, logging, and error handling to be implemented consistently across your application.</p>"},{"location":"user-guide/middleware/#middleware-execution-flow","title":"Middleware Execution Flow","text":"<p>When a request comes in, it passes through middleware in the following order:</p> <ol> <li>The outermost middleware's <code>process_request</code> method</li> <li>The next middleware's <code>process_request</code> method</li> <li>...and so on until the innermost middleware</li> <li>The application handler</li> <li>The innermost middleware's <code>process_response</code> method</li> <li>The next middleware's <code>process_response</code> method</li> <li>...and so on until the outermost middleware</li> <li>The final response is returned to the client</li> </ol> <p>This flow can be visualized as:</p> <pre><code>graph TD\n    A[\"Middleware 1: process_request\"] --&gt; B[\"Middleware 2: process_request\"];\n    B --&gt; C[\"Application Handler\"];\n    C --&gt; D[\"Middleware 2: process_response\"];\n    D --&gt; E[\"Middleware 1: process_response\"];\n</code></pre>"},{"location":"user-guide/middleware/#creating-a-middleware","title":"Creating a Middleware","text":"<p>To create a middleware in Plinx, you need to:</p> <ol> <li>Create a class that inherits from <code>plinx.middleware.Middleware</code></li> <li>Override <code>process_request</code> and/or <code>process_response</code> methods</li> <li>Register the middleware with your application</li> </ol> <p>Here's a basic example:</p> <pre><code>from plinx import Plinx\nfrom plinx.middleware import Middleware\n\n# Create a middleware class\nclass SimpleLoggingMiddleware(Middleware):\n    def process_request(self, request):\n        print(f\"Request received: {request.method} {request.path}\")\n        # You can modify the request here if needed\n\n    def process_response(self, request, response):\n        print(f\"Response generated: {response.status_code}\")\n        # You can modify the response here if needed\n\n# Register the middleware with your application\napp = Plinx()\napp.add_middleware(SimpleLoggingMiddleware)\n</code></pre>"},{"location":"user-guide/middleware/#common-middleware-use-cases","title":"Common Middleware Use Cases","text":""},{"location":"user-guide/middleware/#authentication-middleware","title":"Authentication Middleware","text":"<pre><code>class AuthenticationMiddleware(Middleware):\n    def process_request(self, request):\n        request.user = None\n        auth_header = request.headers.get(\"Authorization\", \"\")\n\n        if auth_header.startswith(\"Bearer \"):\n            token = auth_header[7:]\n            try:\n                # Validate token and get user (implementation depends on your auth system)\n                request.user = self.get_user_from_token(token)\n            except Exception:\n                # Token is invalid\n                pass\n\n    def get_user_from_token(self, token):\n        # Implement your token validation logic here\n        pass\n</code></pre>"},{"location":"user-guide/middleware/#cors-middleware","title":"CORS Middleware","text":"<pre><code>class CORSMiddleware(Middleware):\n    def process_response(self, request, response):\n        response.headers[\"Access-Control-Allow-Origin\"] = \"*\"\n        response.headers[\"Access-Control-Allow-Methods\"] = \"GET, POST, PUT, DELETE, OPTIONS\"\n        response.headers[\"Access-Control-Allow-Headers\"] = \"Content-Type, Authorization\"\n</code></pre>"},{"location":"user-guide/middleware/#request-timing-middleware","title":"Request Timing Middleware","text":"<pre><code>import time\n\nclass TimingMiddleware(Middleware):\n    def process_request(self, request):\n        request.start_time = time.time()\n\n    def process_response(self, request, response):\n        if hasattr(request, \"start_time\"):\n            duration = time.time() - request.start_time\n            response.headers[\"X-Request-Duration\"] = f\"{duration:.6f}\"\n</code></pre>"},{"location":"user-guide/middleware/#order-of-middleware-execution","title":"Order of Middleware Execution","text":"<p>The order in which you add middleware to your application is important. Middleware added first will be the outermost layer (first to process requests, last to process responses). Middleware added last will be the innermost layer (last to process requests, first to process responses).</p> <pre><code>app = Plinx()\n\n# First added = outermost layer\napp.add_middleware(SecurityMiddleware)  # Will process requests first\napp.add_middleware(LoggingMiddleware)   # Will process requests second\napp.add_middleware(TimingMiddleware)    # Will process requests last, responses first\n</code></pre>"},{"location":"user-guide/middleware/#best-practices","title":"Best Practices","text":"<ol> <li>Keep middleware focused: Each middleware should have a single responsibility</li> <li>Be mindful of the execution order: Add middleware in the correct order</li> <li>Avoid heavy processing: Middleware runs for every request, so keep it efficient</li> <li>Pass data through request attributes: To share data between middleware and handlers</li> <li>Consider short-circuiting: Return a response early from <code>process_request</code> for things like authentication failures</li> </ol>"},{"location":"user-guide/responses/","title":"Responses","text":"<p>Plinx provides a flexible response system that makes it easy to return different types of content to clients. This guide explains how to work with response objects and demonstrates various response techniques.</p>"},{"location":"user-guide/responses/#response-object","title":"Response Object","text":"<p>The response object in Plinx is an instance of <code>plinx.response.PlinxResponse</code> that is passed to every handler. It provides methods and properties for setting response data, status codes, and headers:</p> <pre><code>@app.route(\"/example\")\ndef handler(request, response):\n    response.text = \"Hello, World!\"\n    response.status_code = 200\n    response.headers[\"X-Custom-Header\"] = \"Value\"\n</code></pre>"},{"location":"user-guide/responses/#common-response-properties","title":"Common Response Properties","text":"<p>The response object provides several properties for working with different content types:</p> Property Description <code>response.text</code> Set response body as plain text <code>response.json</code> Set response body from a JSON-serializable object <code>response.body</code> Set raw response body as bytes <code>response.content_type</code> Set the Content-Type header <code>response.status_code</code> Set the HTTP status code <code>response.headers</code> Dictionary-like object for setting HTTP headers"},{"location":"user-guide/responses/#text-responses","title":"Text Responses","text":"<p>The simplest way to send a response is to set the <code>text</code> property:</p> <pre><code>@app.route(\"/text\")\ndef text_handler(request, response):\n    response.text = \"This is a plain text response\"\n    # Content-Type is automatically set to text/plain\n</code></pre>"},{"location":"user-guide/responses/#json-responses","title":"JSON Responses","text":"<p>Setting the <code>json</code> property automatically serializes the data and sets the appropriate content type:</p> <pre><code>@app.route(\"/json\")\ndef json_handler(request, response):\n    response.json = {\n        \"message\": \"Success\",\n        \"data\": {\n            \"items\": [1, 2, 3],\n            \"total\": 3\n        }\n    }\n    # Content-Type is automatically set to application/json\n</code></pre> <p>The JSON serialization handles various Python types:</p> <pre><code>@app.route(\"/complex-json\")\ndef complex_json_handler(request, response):\n    from datetime import datetime\n\n    response.json = {\n        \"string\": \"Hello\",\n        \"number\": 42,\n        \"float\": 3.14,\n        \"boolean\": True,\n        \"none\": None,\n        \"list\": [1, 2, 3],\n        \"dict\": {\"key\": \"value\"},\n        \"date\": datetime.now()  # Will be converted to ISO format string\n    }\n</code></pre>"},{"location":"user-guide/responses/#status-codes","title":"Status Codes","text":"<p>HTTP status codes indicate the result of the request. Plinx provides a <code>status_codes</code> module with constants for common codes:</p> <pre><code>from plinx import Plinx\nfrom plinx.status_codes import HTTP_200_OK, HTTP_201_CREATED, HTTP_404_NOT_FOUND\n\napp = Plinx()\n\n@app.route(\"/success\")\ndef success_handler(request, response):\n    response.status_code = HTTP_200_OK\n    response.json = {\"message\": \"Success\"}\n\n@app.route(\"/created\")\ndef created_handler(request, response):\n    response.status_code = HTTP_201_CREATED\n    response.json = {\"message\": \"Resource created\"}\n\n@app.route(\"/not-found\")\ndef not_found_handler(request, response):\n    response.status_code = HTTP_404_NOT_FOUND\n    response.json = {\"error\": \"Resource not found\"}\n</code></pre>"},{"location":"user-guide/responses/#setting-headers","title":"Setting Headers","text":"<p>HTTP headers provide additional information about the response:</p> <pre><code>@app.route(\"/headers\")\ndef headers_handler(request, response):\n    response.text = \"Response with custom headers\"\n\n    # Set individual headers\n    response.headers[\"X-Custom-Header\"] = \"Value\"\n    response.headers[\"Cache-Control\"] = \"no-cache\"\n\n    # Set Content-Type explicitly\n    response.content_type = \"text/plain; charset=utf-8\"\n</code></pre>"},{"location":"user-guide/responses/#binary-responses","title":"Binary Responses","text":"<p>For binary data, use the <code>body</code> property with bytes:</p> <pre><code>@app.route(\"/binary\")\ndef binary_handler(request, response):\n    # Create some binary data\n    binary_data = b\"\\x00\\x01\\x02\\x03\\x04\"\n\n    response.body = binary_data\n    response.content_type = \"application/octet-stream\"\n</code></pre>"},{"location":"user-guide/responses/#file-downloads","title":"File Downloads","text":"<p>You can serve files for download:</p> <pre><code>import os\n\n@app.route(\"/download\")\ndef download_handler(request, response):\n    # Read a file\n    file_path = os.path.join(os.path.dirname(__file__), \"files/document.pdf\")\n\n    with open(file_path, \"rb\") as f:\n        file_data = f.read()\n\n    # Set response\n    response.body = file_data\n    response.content_type = \"application/pdf\"\n\n    # Set headers for download\n    filename = os.path.basename(file_path)\n    response.headers[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'\n    response.headers[\"Content-Length\"] = str(len(file_data))\n</code></pre>"},{"location":"user-guide/responses/#html-responses","title":"HTML Responses","text":"<p>For HTML content, set the appropriate content type:</p> <pre><code>@app.route(\"/html\")\ndef html_handler(request, response):\n    html = \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Plinx Example&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello from Plinx&lt;/h1&gt;\n        &lt;p&gt;This is an HTML response.&lt;/p&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    response.text = html\n    response.content_type = \"text/html\"\n</code></pre>"},{"location":"user-guide/responses/#redirects","title":"Redirects","text":"<p>To redirect the client to another URL:</p> <pre><code>@app.route(\"/redirect\")\ndef redirect_handler(request, response):\n    # Set status code for redirect\n    response.status_code = 302  # or 301 for permanent redirect\n\n    # Set the Location header\n    response.headers[\"Location\"] = \"/target-url\"\n\n    # Optional message\n    response.text = \"Redirecting...\"\n</code></pre>"},{"location":"user-guide/responses/#error-responses","title":"Error Responses","text":"<p>For error responses, it's good practice to return a consistent format:</p> <pre><code>@app.route(\"/error\")\ndef error_handler(request, response):\n    response.status_code = 500\n    response.json = {\n        \"error\": {\n            \"code\": \"INTERNAL_ERROR\",\n            \"message\": \"An unexpected error occurred\",\n            \"details\": \"Database connection failed\"\n        }\n    }\n</code></pre>"},{"location":"user-guide/responses/#content-negotiation","title":"Content Negotiation","text":"<p>You can implement content negotiation to return different formats based on the <code>Accept</code> header:</p> <pre><code>@app.route(\"/negotiate\")\ndef negotiate_handler(request, response):\n    data = {\"name\": \"Example\", \"value\": 42}\n\n    # Get the Accept header\n    accept = request.headers.get(\"Accept\", \"\")\n\n    if \"application/xml\" in accept:\n        # Return XML\n        xml = f\"&lt;data&gt;&lt;name&gt;{data['name']}&lt;/name&gt;&lt;value&gt;{data['value']}&lt;/value&gt;&lt;/data&gt;\"\n        response.text = xml\n        response.content_type = \"application/xml\"\n    else:\n        # Default to JSON\n        response.json = data\n</code></pre>"},{"location":"user-guide/responses/#streaming-responses","title":"Streaming Responses","text":"<p>For large responses, you might want to stream the data:</p> <pre><code>@app.route(\"/stream\")\ndef stream_handler(request, response):\n    def generate_large_data():\n        for i in range(1000):\n            yield f\"Line {i}\\n\".encode()\n\n    # Set streaming response\n    response.body_iter = generate_large_data()\n    response.content_type = \"text/plain\"\n</code></pre>"},{"location":"user-guide/responses/#cookies","title":"Cookies","text":"<p>Setting cookies in the response:</p> <pre><code>@app.route(\"/cookies\")\ndef cookie_handler(request, response):\n    # Set a simple cookie\n    response.set_cookie(\"session\", \"abc123\")\n\n    # Set a cookie with additional parameters\n    response.set_cookie(\n        \"user_id\",\n        \"123\",\n        max_age=3600,  # 1 hour\n        path=\"/\",\n        secure=True,\n        httponly=True,\n        samesite=\"Lax\"\n    )\n\n    response.text = \"Cookies set\"\n</code></pre>"},{"location":"user-guide/responses/#cors-headers","title":"CORS Headers","text":"<p>For cross-origin requests, you'll need to add appropriate CORS headers:</p> <pre><code>@app.route(\"/api/data\")\ndef cors_handler(request, response):\n    # Add CORS headers\n    response.headers[\"Access-Control-Allow-Origin\"] = \"*\"\n    response.headers[\"Access-Control-Allow-Methods\"] = \"GET, POST, PUT, DELETE, OPTIONS\"\n    response.headers[\"Access-Control-Allow-Headers\"] = \"Content-Type, Authorization\"\n\n    # Handle preflight OPTIONS request\n    if request.method == \"OPTIONS\":\n        response.text = \"\"\n        return\n\n    # Regular response\n    response.json = {\"message\": \"CORS-enabled endpoint\"}\n</code></pre>"},{"location":"user-guide/responses/#response-templates","title":"Response Templates","text":"<p>For complex responses, you might want to create a helper function:</p> <pre><code>def create_api_response(data=None, error=None, meta=None, status_code=200):\n    \"\"\"Create a consistent API response structure.\"\"\"\n    response_data = {\n        \"data\": data or {},\n        \"error\": error,\n        \"meta\": meta or {},\n        \"timestamp\": datetime.now().isoformat()\n    }\n\n    if error:\n        if not status_code or status_code &lt; 400:\n            status_code = 400\n\n    return response_data, status_code\n\n@app.route(\"/api/users\")\ndef users_handler(request, response):\n    try:\n        user_data = {\"id\": 1, \"name\": \"John Doe\"}\n        response_data, status_code = create_api_response(\n            data=user_data,\n            meta={\"version\": \"1.0\"}\n        )\n\n        response.json = response_data\n        response.status_code = status_code\n\n    except Exception as e:\n        response_data, status_code = create_api_response(\n            error={\"message\": str(e), \"type\": type(e).__name__},\n            status_code=500\n        )\n\n        response.json = response_data\n        response.status_code = status_code\n</code></pre>"},{"location":"user-guide/responses/#best-practices","title":"Best Practices","text":"<ol> <li>Be consistent: Use a consistent format for your API responses</li> <li>Use appropriate status codes: Follow HTTP standard conventions</li> <li>Set correct content types: Make sure the Content-Type matches your content</li> <li>Handle errors gracefully: Return meaningful error messages</li> <li>Consider content negotiation: Support different formats based on client needs</li> <li>Manage response size: Consider pagination for large data sets</li> <li>Document your API: Include examples of response formats in your API documentation</li> <li>Follow security practices: Set appropriate security headers and cookie flags</li> </ol> <p>By following these practices, you can create clear and consistent responses in your Plinx applications.</p>"},{"location":"user-guide/routing/","title":"Routing","text":"<p>Routing is a fundamental part of any web framework, mapping URL paths to handler functions or classes. Plinx provides a flexible routing system with support for both function and class-based handlers, dynamic URL parameters, and HTTP method constraints.</p>"},{"location":"user-guide/routing/#basic-routing","title":"Basic Routing","text":"<p>The most basic way to define a route in Plinx is using the <code>@app.route()</code> decorator:</p> <pre><code>from plinx import Plinx\n\napp = Plinx()\n\n@app.route(\"/hello\")\ndef hello(request, response):\n    response.text = \"Hello, World!\"\n</code></pre> <p>This registers the <code>hello</code> function to handle requests to the <code>/hello</code> URL path. By default, this route will only respond to GET requests.</p>"},{"location":"user-guide/routing/#http-method-specific-routes","title":"HTTP Method-Specific Routes","text":"<p>Plinx provides method-specific decorators for all standard HTTP methods:</p> <pre><code>@app.get(\"/users\")\ndef get_users(request, response):\n    response.json = {\"users\": [\"user1\", \"user2\"]}\n\n@app.post(\"/users\")\ndef create_user(request, response):\n    response.text = \"User created\"\n    response.status_code = 201  # Created\n\n@app.put(\"/users/{id}\")\ndef update_user(request, response, id):\n    response.text = f\"Updated user {id}\"\n\n@app.delete(\"/users/{id}\")\ndef delete_user(request, response, id):\n    response.text = f\"Deleted user {id}\"\n\n@app.patch(\"/users/{id}\")\ndef patch_user(request, response, id):\n    response.text = f\"Partially updated user {id}\"\n\n@app.options(\"/users\")\ndef options_users(request, response):\n    response.headers[\"Allow\"] = \"GET, POST, PUT, DELETE, PATCH, OPTIONS\"\n    response.status_code = 204  # No Content\n</code></pre> <p>These decorators make your code more explicit about which HTTP methods are expected and handled.</p>"},{"location":"user-guide/routing/#dynamic-url-parameters","title":"Dynamic URL Parameters","text":"<p>Plinx supports dynamic URL parameters using the <code>{param_name}</code> syntax from the <code>parse</code> library:</p> <pre><code>@app.route(\"/posts/{post_id}\")\ndef get_post(request, response, post_id):\n    response.json = {\"post_id\": post_id, \"title\": f\"Post {post_id}\"}\n</code></pre> <p>When a request is made to <code>/posts/123</code>, the <code>post_id</code> parameter will be passed to the handler function with the value <code>\"123\"</code>.</p> <p>You can use multiple parameters in a single URL:</p> <pre><code>@app.route(\"/users/{user_id}/posts/{post_id}\")\ndef get_user_post(request, response, user_id, post_id):\n    response.json = {\n        \"user_id\": user_id,\n        \"post_id\": post_id,\n        \"title\": f\"Post {post_id} by User {user_id}\"\n    }\n</code></pre>"},{"location":"user-guide/routing/#parameter-types","title":"Parameter Types","text":"<p>Currently, URL parameters are passed to handlers as strings. For type conversion, you'll need to handle it in your handler function:</p> <pre><code>@app.route(\"/products/{product_id}\")\ndef get_product(request, response, product_id):\n    # Convert string to integer\n    product_id = int(product_id)\n    # Rest of the handler code...\n    response.text = f\"Product ID: {product_id}\"\n</code></pre>"},{"location":"user-guide/routing/#class-based-handlers","title":"Class-Based Handlers","text":"<p>For resources that respond to multiple HTTP methods, class-based handlers are more convenient:</p> <pre><code>@app.route(\"/api/books\")\nclass BookResource:\n    def get(self, request, response):\n        response.json = {\"books\": [\"Book 1\", \"Book 2\"]}\n\n    def post(self, request, response):\n        response.text = \"Book created\"\n        response.status_code = 201\n</code></pre> <p>When a request is made to <code>/api/books</code>, Plinx will:</p> <ol> <li>Instantiate the <code>BookResource</code> class</li> <li>Look for a method matching the HTTP method name (lowercase)</li> <li>Call that method with the request and response objects</li> </ol> <p>Class-based handlers also support URL parameters:</p> <pre><code>@app.route(\"/api/books/{book_id}\")\nclass BookDetailResource:\n    def get(self, request, response, book_id):\n        response.json = {\"id\": book_id, \"title\": f\"Book {book_id}\"}\n\n    def put(self, request, response, book_id):\n        response.text = f\"Updated book {book_id}\"\n\n    def delete(self, request, response, book_id):\n        response.text = f\"Deleted book {book_id}\"\n</code></pre>"},{"location":"user-guide/routing/#manual-route-registration","title":"Manual Route Registration","text":"<p>If you prefer not to use decorators, you can register routes manually using the <code>add_route</code> method:</p> <pre><code>def user_profile(request, response, user_id):\n    response.text = f\"Profile for user {user_id}\"\n\napp.add_route(\"/users/{user_id}/profile\", user_profile)\n</code></pre> <p>For class-based handlers:</p> <pre><code>class ProductResource:\n    def get(self, request, response):\n        response.json = {\"products\": [\"Product 1\", \"Product 2\"]}\n\napp.add_route(\"/products\", ProductResource)\n</code></pre> <p>To specify an HTTP method other than GET:</p> <pre><code>from plinx.methods import HTTPMethods\n\ndef create_category(request, response):\n    response.text = \"Category created\"\n\napp.add_route(\"/categories\", create_category, method=HTTPMethods.POST)\n</code></pre>"},{"location":"user-guide/routing/#method-not-allowed-handling","title":"Method Not Allowed Handling","text":"<p>If a request is made with an HTTP method that's not supported by the route:</p> <ul> <li>For function-based handlers: Plinx returns a 405 Method Not Allowed response</li> <li>For class-based handlers: If the class doesn't have a method matching the HTTP method, Plinx returns a 405 Method Not Allowed response</li> </ul>"},{"location":"user-guide/routing/#404-not-found-handling","title":"404 Not Found Handling","text":"<p>If no route matches the requested URL path, Plinx returns a 404 Not Found response.</p> <p>You can customize this behavior by adding a custom exception handler:</p> <pre><code>def custom_404_handler(request, response, exception):\n    response.status_code = 404\n    response.text = \"Sorry, the page you're looking for doesn't exist.\"\n\napp.add_exception_handler(custom_404_handler)\n</code></pre>"},{"location":"user-guide/routing/#route-organization","title":"Route Organization","text":"<p>For larger applications, you might want to organize your routes into modules. Here's one approach:</p> <pre><code># routes/users.py\ndef register_routes(app):\n    @app.route(\"/users\")\n    class UserResource:\n        def get(self, request, response):\n            response.json = {\"users\": [\"user1\", \"user2\"]}\n\n        def post(self, request, response):\n            response.text = \"User created\"\n\n# routes/posts.py\ndef register_routes(app):\n    @app.route(\"/posts\")\n    def get_posts(request, response):\n        response.json = {\"posts\": [\"post1\", \"post2\"]}\n\n# main.py\nfrom plinx import Plinx\nfrom routes import users, posts\n\napp = Plinx()\nusers.register_routes(app)\nposts.register_routes(app)\n</code></pre> <p>This approach helps keep your code organized and maintainable as your application grows.</p>"}]}